# Interrupt Handling

## üéØ Layman's Explanation

**What is an Interrupt?**
Imagine you're reading a book, and suddenly your phone rings. You:
1. Stop reading (save your place)
2. Answer the phone (handle interrupt)
3. Hang up
4. Resume reading

That's exactly what an interrupt is - hardware saying "**HEY! URGENT! DEAL WITH ME NOW!**"

**Why Interrupts?**
Without interrupts, the CPU would have to constantly check: "Is the keyboard pressed? Is data arriving? Is the disk ready?" This is called **polling** and it's wasteful.

With interrupts, hardware says "I'll tell you when I need you" - much more efficient!

**Real-World Examples:**
- **Keyboard press** ‚Üí Interrupt ‚Üí Kernel reads the key
- **Network packet arrives** ‚Üí Interrupt ‚Üí Kernel processes it
- **USB device plugged in** ‚Üí Interrupt ‚Üí Kernel detects it
- **Timer expires** ‚Üí Interrupt ‚Üí Kernel updates time

**The Interrupt Flow:**
```
CPU doing normal work
    ‚Üì
[INTERRUPT!] ‚Üê Hardware screams
    ‚Üì
CPU: "Hold on, let me save what I'm doing"
    ‚Üì
CPU jumps to Interrupt Handler (your driver code)
    ‚Üì
Handler: "Got it, I'll handle this quickly"
    ‚Üì
Handler finishes
    ‚Üì
CPU: "Okay, back to what I was doing"
```

**Top Half vs Bottom Half (Important Concept!):**

**Problem:** Interrupt handlers must be FAST. If you take too long, you might miss other interrupts.

**Solution:** Split the work:
- **Top Half** = Urgent stuff (acknowledge interrupt, read critical data) - FAST!
- **Bottom Half** = Slower processing (process the data) - Can take time

**Analogy:**
You're cooking and the doorbell rings:
- **Top Half** = Open door, grab package, close door (quick!)
- **Bottom Half** = Later, open package and use contents (can take time)

**Types of Bottom Half Mechanisms:**
1. **Tasklet** - Simple, runs soon after interrupt
2. **Workqueue** - Can sleep, more flexible
3. **Threaded IRQ** - Modern approach, easier to use

**Interrupt Context Rules:**
When in interrupt handler, you CANNOT:
- Sleep (no waiting)
- Use locks that might sleep
- Access user space memory
- Take too long

**Think of it as:**
You're a surgeon in an emergency:
- Must act fast
- Can't take a coffee break
- Can't leave the room
- Must stabilize patient, then let others do detailed work

## Overview

Interrupts are signals from hardware devices that require immediate attention from the CPU. Interrupt handlers are kernel functions that respond to these signals. This chapter covers interrupt handling in Linux device drivers.

## Interrupt Basics

### Types of Interrupts

**Hardware Interrupts:**
- Generated by hardware devices
- Asynchronous to CPU execution
- Examples: keyboard, network card, timer

**Software Interrupts:**
- Generated by software (system calls, exceptions)
- Synchronous to CPU execution

### Interrupt Flow

```
1. Device generates interrupt signal
2. CPU stops current execution
3. Saves context
4. Jumps to interrupt handler
5. Handler processes interrupt
6. Restores context
7. Resumes execution
```

## Requesting Interrupts

### request_irq Function

```c
#include <linux/interrupt.h>

int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev_id);
```

Parameters:
- `irq`: Interrupt number
- `handler`: Interrupt handler function
- `flags`: Interrupt flags
- `name`: Device name (shown in /proc/interrupts)
- `dev_id`: Device identifier (for shared interrupts)

### Interrupt Flags

```c
IRQF_SHARED        // Shared interrupt line
IRQF_TRIGGER_RISING    // Rising edge triggered
IRQF_TRIGGER_FALLING   // Falling edge triggered
IRQF_TRIGGER_HIGH      // High level triggered
IRQF_TRIGGER_LOW       // Low level triggered
IRQF_ONESHOT       // Handler runs with interrupts disabled
```

### Example

```c
static irqreturn_t my_interrupt_handler(int irq, void *dev_id)
{
    // Handle interrupt
    printk(KERN_INFO "Interrupt received: IRQ %d\n", irq);
    return IRQ_HANDLED;
}

static int __init my_init(void)
{
    int ret;
    int irq = 42;
    
    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED,
                     "mydevice", &my_device);
    if (ret) {
        printk(KERN_ERR "Failed to request IRQ %d: %d\n", irq, ret);
        return ret;
    }
    
    printk(KERN_INFO "IRQ %d registered\n", irq);
    return 0;
}
```

## Freeing Interrupts

```c
void free_irq(unsigned int irq, void *dev_id);

static void __exit my_exit(void)
{
    free_irq(irq, &my_device);
    printk(KERN_INFO "IRQ freed\n");
}
```

## Interrupt Handler

### Handler Signature

```c
irqreturn_t handler(int irq, void *dev_id);
```

Return values:
- `IRQ_HANDLED`: Interrupt was handled
- `IRQ_NONE`: Interrupt not from this device
- `IRQ_WAKE_THREAD`: Wake threaded handler

### Handler Constraints

**Cannot:**
- Sleep or block
- Call functions that might sleep
- Transfer data to/from user space
- Use mutexes
- Allocate memory with GFP_KERNEL

**Can:**
- Use spinlocks
- Allocate memory with GFP_ATOMIC
- Access hardware registers
- Schedule tasklets or work queues

### Example Handler

```c
static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    u32 status;
    
    // Read interrupt status
    status = ioread32(dev->base + STATUS_REG);
    
    // Check if interrupt is from our device
    if (!(status & IRQ_FLAG))
        return IRQ_NONE;
    
    // Clear interrupt
    iowrite32(IRQ_FLAG, dev->base + STATUS_REG);
    
    // Process interrupt
    if (status & RX_READY) {
        // Handle received data
        dev->rx_count++;
    }
    
    if (status & TX_COMPLETE) {
        // Handle transmission complete
        dev->tx_count++;
    }
    
    // Wake up waiting processes
    wake_up_interruptible(&dev->wait_queue);
    
    return IRQ_HANDLED;
}
```

## Shared Interrupts

Multiple devices sharing the same interrupt line.

```c
static irqreturn_t shared_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    u32 status;
    
    status = ioread32(dev->base + STATUS_REG);
    
    // Check if interrupt is from our device
    if (!(status & MY_IRQ_BIT))
        return IRQ_NONE;  // Not our interrupt
    
    // Handle interrupt
    // ...
    
    return IRQ_HANDLED;
}

// Request shared interrupt
ret = request_irq(irq, shared_handler, IRQF_SHARED, "mydev", dev);
```

**Requirements for shared interrupts:**
- Must provide unique `dev_id`
- Must check if interrupt is from device
- Return `IRQ_NONE` if not from device

## Threaded Interrupts

For handlers that need to perform lengthy operations.

```c
static irqreturn_t my_hard_irq(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    
    // Quick hardware acknowledgment
    iowrite32(IRQ_ACK, dev->base + STATUS_REG);
    
    // Request thread handler
    return IRQ_WAKE_THREAD;
}

static irqreturn_t my_thread_fn(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    
    // Lengthy processing (can sleep)
    process_data(dev);
    
    return IRQ_HANDLED;
}

// Request threaded interrupt
ret = request_threaded_irq(irq, my_hard_irq, my_thread_fn,
                          IRQF_ONESHOT, "mydev", dev);
```

## Deferred Work

### Tasklets

Lightweight deferred execution in interrupt context.

```c
#include <linux/interrupt.h>

static void my_tasklet_func(unsigned long data)
{
    struct my_device *dev = (struct my_device *)data;
    
    // Process deferred work
    printk(KERN_INFO "Tasklet executed\n");
}

DECLARE_TASKLET(my_tasklet, my_tasklet_func, (unsigned long)&my_device);

// In interrupt handler
static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    // Quick processing
    
    // Schedule tasklet
    tasklet_schedule(&my_tasklet);
    
    return IRQ_HANDLED;
}

// Cleanup
tasklet_kill(&my_tasklet);
```

### Work Queues

Deferred execution in process context (can sleep).

```c
#include <linux/workqueue.h>

static void my_work_func(struct work_struct *work)
{
    struct my_device *dev = container_of(work, struct my_device, work);
    
    // Can sleep, allocate memory, etc.
    printk(KERN_INFO "Work executed\n");
}

// In device structure
struct my_device {
    struct work_struct work;
    // ...
};

// Initialize
INIT_WORK(&dev->work, my_work_func);

// In interrupt handler
static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    struct my_device *dev = dev_id;
    
    // Quick processing
    
    // Schedule work
    schedule_work(&dev->work);
    
    return IRQ_HANDLED;
}

// Cleanup
cancel_work_sync(&dev->work);
```

## Complete Interrupt Example

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>
#include <linux/io.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/wait.h>

#define DEVICE_NAME "irqdev"

struct irq_device {
    void __iomem *base;
    int irq;
    struct cdev cdev;
    dev_t devt;
    wait_queue_head_t wait_queue;
    int data_ready;
    u32 data;
    spinlock_t lock;
};

static irqreturn_t irq_handler(int irq, void *dev_id)
{
    struct irq_device *dev = dev_id;
    unsigned long flags;
    u32 status;
    
    // Read status register
    status = ioread32(dev->base);
    
    // Check if our interrupt
    if (!(status & 0x1))
        return IRQ_NONE;
    
    spin_lock_irqsave(&dev->lock, flags);
    
    // Read data
    dev->data = ioread32(dev->base + 4);
    dev->data_ready = 1;
    
    // Clear interrupt
    iowrite32(0x1, dev->base);
    
    spin_unlock_irqrestore(&dev->lock, flags);
    
    // Wake up waiting processes
    wake_up_interruptible(&dev->wait_queue);
    
    return IRQ_HANDLED;
}

static int irqdev_open(struct inode *inode, struct file *filp)
{
    struct irq_device *dev;
    dev = container_of(inode->i_cdev, struct irq_device, cdev);
    filp->private_data = dev;
    return 0;
}

static ssize_t irqdev_read(struct file *filp, char __user *buf,
                          size_t count, loff_t *f_pos)
{
    struct irq_device *dev = filp->private_data;
    unsigned long flags;
    u32 data;
    
    // Wait for data
    if (wait_event_interruptible(dev->wait_queue, dev->data_ready))
        return -ERESTARTSYS;
    
    spin_lock_irqsave(&dev->lock, flags);
    data = dev->data;
    dev->data_ready = 0;
    spin_unlock_irqrestore(&dev->lock, flags);
    
    if (copy_to_user(buf, &data, sizeof(data)))
        return -EFAULT;
    
    return sizeof(data);
}

static struct file_operations irqdev_fops = {
    .owner = THIS_MODULE,
    .open = irqdev_open,
    .read = irqdev_read,
};

static int irqdev_probe(struct platform_device *pdev)
{
    struct irq_device *dev;
    struct resource *res;
    int ret;
    
    dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return -ENOMEM;
    
    // Get resources
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    dev->base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(dev->base))
        return PTR_ERR(dev->base);
    
    dev->irq = platform_get_irq(pdev, 0);
    if (dev->irq < 0)
        return dev->irq;
    
    // Initialize
    spin_lock_init(&dev->lock);
    init_waitqueue_head(&dev->wait_queue);
    
    // Request interrupt
    ret = devm_request_irq(&pdev->dev, dev->irq, irq_handler,
                          IRQF_SHARED, DEVICE_NAME, dev);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }
    
    // Register character device
    ret = alloc_chrdev_region(&dev->devt, 0, 1, DEVICE_NAME);
    if (ret < 0)
        return ret;
    
    cdev_init(&dev->cdev, &irqdev_fops);
    ret = cdev_add(&dev->cdev, dev->devt, 1);
    if (ret < 0) {
        unregister_chrdev_region(dev->devt, 1);
        return ret;
    }
    
    platform_set_drvdata(pdev, dev);
    
    dev_info(&pdev->dev, "Device initialized, IRQ %d\n", dev->irq);
    return 0;
}

static int irqdev_remove(struct platform_device *pdev)
{
    struct irq_device *dev = platform_get_drvdata(pdev);
    
    cdev_del(&dev->cdev);
    unregister_chrdev_region(dev->devt, 1);
    
    return 0;
}

static struct platform_driver irqdev_driver = {
    .probe = irqdev_probe,
    .remove = irqdev_remove,
    .driver = {
        .name = DEVICE_NAME,
    },
};

module_platform_driver(irqdev_driver);

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Interrupt handling example");
```

## Disabling Interrupts

### Local CPU

```c
// Disable interrupts on current CPU
local_irq_disable();
// Critical section
local_irq_enable();

// Save and restore interrupt state
unsigned long flags;
local_irq_save(flags);
// Critical section
local_irq_restore(flags);
```

### Specific Interrupt

```c
// Disable specific interrupt
disable_irq(irq);
// Critical section
enable_irq(irq);

// Disable and wait for handler to complete
disable_irq_nosync(irq);  // Don't wait
```

## Interrupt Statistics

```bash
# View interrupt statistics
cat /proc/interrupts

# View interrupt affinity
cat /proc/irq/42/smp_affinity

# Set interrupt affinity (CPU mask)
echo 2 > /proc/irq/42/smp_affinity
```

## Best Practices

1. **Keep handlers short**: Minimize time in interrupt context
2. **Use deferred work**: For lengthy processing
3. **Avoid sleeping**: Never sleep in interrupt handlers
4. **Check device**: For shared interrupts
5. **Clear interrupt**: Acknowledge hardware interrupt
6. **Use spinlocks**: For synchronization in interrupt context
7. **Return correct value**: IRQ_HANDLED or IRQ_NONE
8. **Test thoroughly**: Interrupt bugs are hard to debug

## Common Pitfalls

- Sleeping in interrupt context
- Using wrong memory allocation flags
- Not checking if interrupt is from device
- Forgetting to clear hardware interrupt
- Deadlocks with spinlocks
- Not freeing interrupt on cleanup

## Debugging

```c
// Check if in interrupt context
if (in_interrupt())
    printk("In interrupt context\n");

// Check if in atomic context
if (in_atomic())
    printk("In atomic context\n");
```

## Next Steps

Proceed to [Synchronization & Waiting Queue](09-synchronization-waiting-queue.md) to learn about kernel synchronization mechanisms.
