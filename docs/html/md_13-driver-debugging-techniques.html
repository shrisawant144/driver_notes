<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux Driver Development Manual: Driver Debugging Techniques</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linux Driver Development Manual
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Comprehensive guide to Linux kernel and device driver development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Driver Debugging Techniques </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md428"></a>
Complete Terminology Glossary</h1>
<p><b>Essential Terms</b> (Must Know):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Kernel Space</b> </td><td class="markdownTableBodyNone">Where kernel and drivers run (privileged) </td><td class="markdownTableBodyNone">Your driver code  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>User Space</b> </td><td class="markdownTableBodyNone">Where normal programs run (protected) </td><td class="markdownTableBodyNone">Firefox, bash  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>printk</b> </td><td class="markdownTableBodyNone">Kernel's printf for logging </td><td class="markdownTableBodyNone"><code>printk("Hello\n");</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>dmesg</b> </td><td class="markdownTableBodyNone">Command to read kernel logs </td><td class="markdownTableBodyNone"><code>dmesg \| tail</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Module</b> </td><td class="markdownTableBodyNone">Loadable kernel code (plugin) </td><td class="markdownTableBodyNone">Your driver .ko file  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Oops</b> </td><td class="markdownTableBodyNone">Kernel bug report (non-fatal) </td><td class="markdownTableBodyNone">NULL pointer crash  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Panic</b> </td><td class="markdownTableBodyNone">Kernel fatal error (system halts) </td><td class="markdownTableBodyNone">Critical hardware failure  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Symbol</b> </td><td class="markdownTableBodyNone">Function/variable name </td><td class="markdownTableBodyNone"><code>kmalloc</code>, <code>my_init</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Stack Trace</b> </td><td class="markdownTableBodyNone">List of function calls </td><td class="markdownTableBodyNone">main→func_a→func_b→BUG  </td></tr>
</table>
<p><b>Memory Terms</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>kmalloc</b> </td><td class="markdownTableBodyNone">Allocate kernel memory </td><td class="markdownTableBodyNone"><code>ptr = kmalloc(100, GFP_KERNEL);</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>kfree</b> </td><td class="markdownTableBodyNone">Free kernel memory </td><td class="markdownTableBodyNone"><code>kfree(ptr);</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Use-after-free</b> </td><td class="markdownTableBodyNone">Access freed memory (BUG!) </td><td class="markdownTableBodyNone"><code>kfree(ptr); *ptr = 42;</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Memory leak</b> </td><td class="markdownTableBodyNone">Forget to free memory </td><td class="markdownTableBodyNone"><code>kmalloc()</code> without <code>kfree()</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Out-of-bounds</b> </td><td class="markdownTableBodyNone">Access beyond array </td><td class="markdownTableBodyNone"><code>array[10]</code> when size is 10  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>GFP_KERNEL</b> </td><td class="markdownTableBodyNone">Can sleep while allocating </td><td class="markdownTableBodyNone">Use in normal context  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>GFP_ATOMIC</b> </td><td class="markdownTableBodyNone">Cannot sleep </td><td class="markdownTableBodyNone">Use in interrupt  </td></tr>
</table>
<p><b>Concurrency Terms</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Race condition</b> </td><td class="markdownTableBodyNone">Two threads access same data </td><td class="markdownTableBodyNone">counter++ from 2 threads  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Spinlock</b> </td><td class="markdownTableBodyNone">Lock that busy-waits </td><td class="markdownTableBodyNone"><code>spin_lock(&amp;lock);</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Mutex</b> </td><td class="markdownTableBodyNone">Lock that sleeps </td><td class="markdownTableBodyNone"><code>mutex_lock(&amp;mutex);</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Atomic</b> </td><td class="markdownTableBodyNone">Cannot be interrupted </td><td class="markdownTableBodyNone"><code>atomic_inc(&amp;counter);</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Deadlock</b> </td><td class="markdownTableBodyNone">Two threads wait for each other </td><td class="markdownTableBodyNone">Thread1 waits for Thread2, vice versa  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Critical section</b> </td><td class="markdownTableBodyNone">Code that needs protection </td><td class="markdownTableBodyNone">Code between lock/unlock  </td></tr>
</table>
<p><b>Debugging Tools</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>debugfs</b> </td><td class="markdownTableBodyNone">Virtual filesystem for debugging </td><td class="markdownTableBodyNone"><code>/sys/kernel/debug/mydriver/</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>ftrace</b> </td><td class="markdownTableBodyNone">Function tracer </td><td class="markdownTableBodyNone">Trace function calls  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>KASAN</b> </td><td class="markdownTableBodyNone">Memory bug detector </td><td class="markdownTableBodyNone">Finds use-after-free  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>lockdep</b> </td><td class="markdownTableBodyNone">Deadlock detector </td><td class="markdownTableBodyNone">Finds lock ordering bugs  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>KGDB</b> </td><td class="markdownTableBodyNone">Kernel debugger </td><td class="markdownTableBodyNone">Like GDB for kernel  </td></tr>
</table>
<p><b>Context Terms</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Process context</b> </td><td class="markdownTableBodyNone">Normal execution, can sleep </td><td class="markdownTableBodyNone">Module init, file operations  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Interrupt context</b> </td><td class="markdownTableBodyNone">Interrupt handler, cannot sleep </td><td class="markdownTableBodyNone">IRQ handler, timer callback  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Atomic context</b> </td><td class="markdownTableBodyNone">Cannot sleep </td><td class="markdownTableBodyNone">Inside spinlock, IRQ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>in_interrupt()</b> </td><td class="markdownTableBodyNone">Check if in interrupt </td><td class="markdownTableBodyNone"><code>if (in_interrupt()) ...</code>  </td></tr>
</table>
<p><b>File System Terms</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Virtual filesystem</b> </td><td class="markdownTableBodyNone">Filesystem in RAM only </td><td class="markdownTableBodyNone">debugfs, sysfs, proc  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>dentry</b> </td><td class="markdownTableBodyNone">Directory entry </td><td class="markdownTableBodyNone">File or folder  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>inode</b> </td><td class="markdownTableBodyNone">File metadata </td><td class="markdownTableBodyNone">Permissions, size  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>file_operations</b> </td><td class="markdownTableBodyNone">How to read/write file </td><td class="markdownTableBodyNone">open, read, write functions  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>seq_file</b> </td><td class="markdownTableBodyNone">Generate large output </td><td class="markdownTableBodyNone">Status dumps  </td></tr>
</table>
<p><b>Hardware Terms</b>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Simple Explanation </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Register</b> </td><td class="markdownTableBodyNone">Hardware control/status </td><td class="markdownTableBodyNone">Device control register  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>MMIO</b> </td><td class="markdownTableBodyNone">Memory-mapped I/O </td><td class="markdownTableBodyNone">Access hardware via memory  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>ioread32</b> </td><td class="markdownTableBodyNone">Read 32-bit register </td><td class="markdownTableBodyNone"><code>val = ioread32(addr);</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>iowrite32</b> </td><td class="markdownTableBodyNone">Write 32-bit register </td><td class="markdownTableBodyNone"><code>iowrite32(val, addr);</code>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>DMA</b> </td><td class="markdownTableBodyNone">Direct Memory Access </td><td class="markdownTableBodyNone">Hardware accesses memory directly  </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md430"></a>
Learning Path for Beginners</h1>
<p>This document is comprehensive and can be overwhelming. Here's a structured learning flow:</p>
<h2><a class="anchor" id="autotoc_md431"></a>
Visual Learning Roadmap</h2>
<p><img src="images/learning_roadmap.png" alt="Learning Roadmap" class="inline"/></p>
<p><b>How to Read This Roadmap</b>:</p><ul>
<li><b>Green boxes</b> = Easy topics (⭐)</li>
<li><b>Orange boxes</b> = Medium topics (⭐⭐⭐)</li>
<li><b>Red boxes</b> = Hard topics (⭐⭐⭐⭐)</li>
<li><b>Yellow boxes</b> = Hands-on labs</li>
<li><b>Dashed lines</b> = Optional shortcuts</li>
</ul>
<h2><a class="anchor" id="autotoc_md432"></a>
Phase 1: Basic Debugging (Week 1-2) - Essential for All Beginners</h2>
<p><b>Goal</b>: Debug simple driver issues using logs</p>
<ol type="1">
<li><b>Start Here</b>: <a href="#printk-debugging">printk Debugging</a> - Learn basic logging<ul>
<li>Practice: Add printk to init/exit functions</li>
<li>Practice: Log function parameters and return values</li>
</ul>
</li>
<li><b>Next</b>: <a href="#pr_-macros">pr_* Macros</a> - Better logging practices<ul>
<li>Practice: Replace printk with pr_info/pr_err</li>
<li>Practice: Use dev_* macros for device drivers</li>
</ul>
</li>
<li><b>Then</b>: <a href="#viewing-messages">Viewing Messages</a> - Read your logs<ul>
<li>Practice: Use dmesg, dmesg -w, journalctl -kf</li>
<li>Practice: Filter logs by level</li>
</ul>
</li>
</ol>
<p><b>Skills Gained</b>: 60% of debugging needs - Can debug module loading, basic errors, function flow</p>
<p><b>Time Investment</b>: 5-10 hours | <b>Difficulty</b>: ⭐☆☆☆☆</p>
<hr  />
<h2><a class="anchor" id="autotoc_md434"></a>
Phase 2: Runtime Debugging (Week 3-4) - Intermediate</h2>
<p><b>Goal</b>: Debug without recompiling</p>
<ol type="1">
<li><b>Dynamic Debug</b> - Toggle debug messages at runtime<ul>
<li>Practice: Enable/disable debug for your module</li>
<li>Practice: Filter by file and function</li>
</ul>
</li>
<li><b>Debugfs</b> - Expose driver state<ul>
<li>Practice: Create simple debugfs files (u32, bool)</li>
<li>Practice: Read driver counters via debugfs</li>
</ul>
</li>
</ol>
<p><b>Skills Gained</b>: 75% coverage - Can debug timing issues, inspect runtime state</p>
<p><b>Time Investment</b>: 10-15 hours | <b>Difficulty</b>: ⭐⭐☆☆☆</p>
<hr  />
<h2><a class="anchor" id="autotoc_md436"></a>
Phase 3: Advanced Analysis (Week 5-8) - Advanced</h2>
<p><b>Goal</b>: Find complex bugs (crashes, races, leaks)</p>
<ol type="1">
<li><b>Oops Analysis</b> - Understand kernel crashes<ul>
<li>Practice: Decode stack traces with addr2line</li>
<li>Practice: Identify NULL pointer dereferences</li>
</ul>
</li>
<li><b>Memory Debugging</b> - Find memory bugs<ul>
<li>Start with: KASAN (easiest, most powerful)</li>
<li>Practice: Enable KASAN, trigger use-after-free</li>
<li>Then: kmemleak for leak detection</li>
</ul>
</li>
<li><b>Lock Debugging</b> - Find deadlocks and races<ul>
<li>Start with: Lockdep (automatic detection)</li>
<li>Practice: Enable lockdep, test with multiple threads</li>
</ul>
</li>
</ol>
<p><b>Skills Gained</b>: 90% coverage - Can debug crashes, memory corruption, deadlocks</p>
<p><b>Time Investment</b>: 20-30 hours | <b>Difficulty</b>: ⭐⭐⭐☆☆</p>
<hr  />
<h2><a class="anchor" id="autotoc_md438"></a>
Phase 4: Expert Tools (Month 3+) - Expert</h2>
<p><b>Goal</b>: Performance analysis and production debugging</p>
<ol type="1">
<li><b>ftrace</b> - Trace kernel functions<ul>
<li>Practice: Trace your driver functions</li>
<li>Practice: Use function_graph for timing</li>
</ul>
</li>
<li><b>perf</b> - Performance profiling<ul>
<li>Practice: Find hot spots in your code</li>
</ul>
</li>
<li><b>KGDB</b> - Interactive debugging (optional)<ul>
<li>Practice: Set breakpoints, inspect variables</li>
</ul>
</li>
</ol>
<p><b>Skills Gained</b>: 95%+ coverage - Production-ready debugging skills</p>
<p><b>Time Investment</b>: 30-50 hours | <b>Difficulty</b>: ⭐⭐⭐⭐☆</p>
<hr  />
<h2><a class="anchor" id="autotoc_md440"></a>
Quick Reference: When to Use What Tool</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Problem </th><th class="markdownTableHeadNone">Tool </th><th class="markdownTableHeadNone">Phase </th><th class="markdownTableHeadNone">Difficulty  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Module won't load </td><td class="markdownTableBodyNone">dmesg, printk </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">⭐  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Function not called </td><td class="markdownTableBodyNone">printk in function </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">⭐  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Wrong value </td><td class="markdownTableBodyNone">printk variable </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">⭐  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Kernel crash/oops </td><td class="markdownTableBodyNone">dmesg, addr2line </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">⭐⭐⭐  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory corruption </td><td class="markdownTableBodyNone">KASAN </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">⭐⭐⭐  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Memory leak </td><td class="markdownTableBodyNone">kmemleak </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">⭐⭐⭐  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Deadlock </td><td class="markdownTableBodyNone">lockdep </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">⭐⭐⭐  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Race condition </td><td class="markdownTableBodyNone">KCSAN, lockdep </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">⭐⭐⭐⭐  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Performance issue </td><td class="markdownTableBodyNone">perf, ftrace </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">⭐⭐⭐⭐  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Timing issue </td><td class="markdownTableBodyNone">ftrace function_graph </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">⭐⭐⭐⭐  </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md442"></a>
Recommended Learning Order (Skip to What You Need)</h2>
<p><b>Absolute Beginner</b> (Never debugged kernel code): → printk → dmesg → pr_* macros → STOP (you can debug 60% of issues)</p>
<p><b>Intermediate</b> (Can write basic drivers): → Review Phase 1 → Dynamic Debug → Debugfs → Oops Analysis → KASAN</p>
<p><b>Advanced</b> (Writing production drivers): → Review Phase 3 → ftrace → perf → Lock debugging → Specific scenarios</p>
<p><b>Expert</b> (Kernel maintainer level): → Read entire document → Focus on Advanced Techniques section</p>
<hr  />
<h2><a class="anchor" id="autotoc_md444"></a>
Practical Exercise Path</h2>
<p><b>Exercise 1</b> (Phase 1): Create a module that logs init/exit </p><div class="fragment"><div class="line">pr_info(<span class="stringliteral">&quot;Module loaded, version=%s\n&quot;</span>, VERSION);</div>
</div><!-- fragment --><p><b>Exercise 2</b> (Phase 1): Add error handling with logs </p><div class="fragment"><div class="line">ptr = kmalloc(size, GFP_KERNEL);</div>
<div class="line"><span class="keywordflow">if</span> (!ptr) {</div>
<div class="line">    pr_err(<span class="stringliteral">&quot;Failed to allocate %zu bytes\n&quot;</span>, size);</div>
<div class="line">    <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Exercise 3</b> (Phase 2): Create debugfs counter </p><div class="fragment"><div class="line">debugfs_create_u32(<span class="stringliteral">&quot;counter&quot;</span>, 0644, debug_dir, &amp;counter);</div>
</div><!-- fragment --><p><b>Exercise 4</b> (Phase 3): Intentionally create NULL deref, decode oops </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *ptr = NULL;</div>
<div class="line">*ptr = 42;  <span class="comment">// Trigger oops, then decode with addr2line</span></div>
</div><!-- fragment --><p><b>Exercise 5</b> (Phase 3): Enable KASAN, create use-after-free </p><div class="fragment"><div class="line">kfree(ptr);</div>
<div class="line">*ptr = 42;  <span class="comment">// KASAN will catch this</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md446"></a>
How Much Does This Help Beginners?</h2>
<p><b>Effectiveness Rating</b>: ⭐⭐⭐⭐⭐ (5/5)</p>
<p><b>Why This Flow Works</b>:</p>
<ol type="1">
<li><b>Progressive Complexity</b>: Start simple (printk) → Advanced (ftrace)<ul>
<li>Beginners aren't overwhelmed</li>
<li>Each phase builds on previous knowledge</li>
</ul>
</li>
<li><b>Practical Focus</b>:<ul>
<li>80% of real-world bugs solved with Phase 1-2 tools</li>
<li>Advanced tools only when needed</li>
</ul>
</li>
<li><b>Time-Efficient</b>:<ul>
<li>Phase 1 (5-10 hours) solves 60% of issues</li>
<li>Phase 2 (10-15 hours) solves 75% of issues</li>
<li>Most developers stop at Phase 3</li>
</ul>
</li>
<li><b>Clear Milestones</b>:<ul>
<li>Each phase has measurable skills</li>
<li>Know when you're "good enough"</li>
</ul>
</li>
</ol>
<p><b>Beginner Success Metrics</b>:</p><ul>
<li>After Phase 1: Can debug 60% of driver issues independently</li>
<li>After Phase 2: Can debug 75% without help</li>
<li>After Phase 3: Can debug 90% including crashes and leaks</li>
<li>After Phase 4: Expert-level, can debug production systems</li>
</ul>
<p><b>Common Beginner Mistakes This Prevents</b>:</p><ul>
<li>❌ Jumping to KGDB before learning printk</li>
<li>❌ Enabling all debug options (system too slow)</li>
<li>❌ Using complex tools for simple problems</li>
<li>❌ Not knowing which tool to use when</li>
</ul>
<p><b>Recommended Time Investment</b>:</p><ul>
<li><b>Hobbyist</b>: Phase 1-2 (15-25 hours total)</li>
<li><b>Professional Driver Developer</b>: Phase 1-3 (35-55 hours)</li>
<li><b>Kernel Maintainer</b>: All phases (65-105 hours)</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md448"></a>
Overview</h1>
<p>Debugging kernel drivers is challenging due to the lack of traditional debugging tools like gdb in user space (though kgdb exists for advanced use). Kernel code runs in privileged mode, so bugs can cause system crashes, panics, or subtle race conditions. This chapter covers various techniques and tools for debugging Linux device drivers, emphasizing non-intrusive methods to avoid altering timing-sensitive behavior.</p>
<h2><a class="anchor" id="autotoc_md449"></a>
Key Terminology Explained</h2>
<p><b>Kernel Space vs User Space</b>:</p><ul>
<li><b>User Space</b>: Where normal programs run (Firefox, bash, etc.). Protected, isolated, can crash without affecting system.</li>
<li><b>Kernel Space</b>: Where kernel and drivers run. Privileged, shared memory, crash affects entire system.</li>
</ul>
<div class="dotgraph">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
</div>
<p><b>Ring Buffer</b>:</p><ul>
<li>Circular memory buffer (like a circular queue)</li>
<li>Fixed size (e.g., 256KB)</li>
<li>When full, oldest data is overwritten</li>
<li>Used by printk to store log messages</li>
</ul>
<div class="dotgraph">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
</div>
<p><b>Atomic Context vs Process Context</b>:</p><ul>
<li><b>Process Context</b>: Normal execution, can sleep, can allocate memory with GFP_KERNEL</li>
<li><b>Atomic Context</b>: Interrupt handler, spinlock held, CANNOT sleep, must use GFP_ATOMIC</li>
</ul>
<div class="dotgraph">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
</div>
<p><b>Oops vs Panic</b>:</p><ul>
<li><b>Oops</b>: Kernel detected a bug but tries to continue (like a warning)</li>
<li><b>Panic</b>: Kernel cannot continue, system halts (like a fatal error)</li>
</ul>
<p><b>Stack Trace</b>:</p><ul>
<li>List of function calls that led to current point</li>
<li>Read bottom-to-top (oldest to newest)</li>
<li>Example: <code>main() → func_a() → func_b() → BUG!</code></li>
</ul>
<p><b>Symbol</b>:</p><ul>
<li>Name of a function or variable in kernel</li>
<li>Example: <code>kmalloc</code>, <code>printk</code>, <code>my_driver_init</code></li>
<li>Stored in <code>/proc/kallsyms</code></li>
</ul>
<p><b>Module</b>:</p><ul>
<li>Loadable kernel code (like a plugin)</li>
<li>Can be loaded/unloaded without rebooting</li>
<li>Your driver is a module!</li>
</ul>
<p><b>Deeper Insight</b>: Kernel debugging often relies on instrumentation (e.g., logs) because stopping execution (breakpoints) can disrupt real-time operations or hardware interactions. Tools like ftrace or perf add runtime overhead but provide visibility into call stacks and events. Always compile the kernel with <code>CONFIG_DEBUG_KERNEL=y</code> to enable these features.</p>
<p><b>Potential Pitfalls</b>: Overusing logs can flood the console and hide critical messages. Use rate-limiting (e.g., <code>pr_info_ratelimited</code>) in high-frequency paths.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md451"></a>
In-Depth Learning Guide</h1>
<p>This section provides comprehensive, step-by-step learning with real examples, common pitfalls, and hands-on exercises.</p>
<h2><a class="anchor" id="autotoc_md452"></a>
Deep Dive 1: Understanding printk Internals</h2>
<p><b>Conceptual Understanding</b>:</p>
<p>printk is NOT like printf. Key differences:</p><ol type="1">
<li><b>Asynchronous</b>: Message stored in ring buffer, printed later</li>
<li><b>No Buffering</b>: Can't use <br  />
 strategically like printf</li>
<li><b>Atomic Safe</b>: Can call from interrupt context</li>
<li><b>Ring Buffer</b>: Fixed size, old messages overwritten</li>
</ol>
<p><b>How printk Actually Works</b> (Internal Flow):</p>
<div class="fragment"><div class="line">Your Code: printk(KERN_INFO &quot;Hello&quot;)</div>
<div class="line">    ↓</div>
<div class="line">1. Format string parsed</div>
<div class="line">    ↓</div>
<div class="line">2. Message stored in log_buf (ring buffer, typically 256KB-1MB)</div>
<div class="line">    ↓</div>
<div class="line">3. If console available → kthread prints to console</div>
<div class="line">    ↓</div>
<div class="line">4. If not → deferred until safe</div>
<div class="line">    ↓</div>
<div class="line">5. User reads via dmesg (reads /dev/kmsg)</div>
</div><!-- fragment --><p><b>Hands-On Lab 1.1</b>: Understanding Ring Buffer Overflow</p>
<div class="fragment"><div class="line"><span class="comment">// lab1_printk_overflow.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab1_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 1: Ring Buffer Test ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Flood the ring buffer</span></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 10000; i++) {</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Message %d: This is a test message to fill the ring buffer\n&quot;</span>, i);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== End of flood ===\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab1_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Lab 1 cleanup\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab1_init);</div>
<div class="line">module_exit(lab1_exit);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>:</p><ol type="1">
<li>Load module: <code>insmod lab1_printk_overflow.ko</code></li>
<li>Check dmesg: <code>dmesg | grep "Message 0"</code> (likely gone!)</li>
<li>Check dmesg: <code>dmesg | grep "Message 9999"</code> (should exist)</li>
<li>Increase buffer: <code>echo 20 &gt; /proc/sys/kernel/printk</code> (see more messages)</li>
</ol>
<p><b>Learning Outcome</b>: Understand ring buffer is finite, old messages lost.</p>
<hr  />
<p><b>Hands-On Lab 1.2</b>: printk in Interrupt Context</p>
<div class="fragment"><div class="line"><span class="comment">// lab2_printk_irq.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/interrupt.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>timer_list my_timer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> timer_callback(<span class="keyword">struct</span> timer_list *t)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// This runs in interrupt context!</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Timer fired in IRQ context\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check context</span></div>
<div class="line">    <span class="keywordflow">if</span> (in_interrupt())</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Confirmed: in_interrupt() = true\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Safe: printk works in IRQ</span></div>
<div class="line">    <span class="comment">// UNSAFE: kmalloc(GFP_KERNEL) would crash here!</span></div>
<div class="line">    </div>
<div class="line">    mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(1000));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab2_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 2: printk in IRQ ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    timer_setup(&amp;my_timer, timer_callback, 0);</div>
<div class="line">    mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(1000));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab2_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    del_timer_sync(&amp;my_timer);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Lab 2 cleanup\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab2_init);</div>
<div class="line">module_exit(lab2_exit);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>:</p><ol type="1">
<li>Load module, watch dmesg -w</li>
<li>See timer firing every second</li>
<li>Try adding <code>msleep(100)</code> in timer_callback (will crash!)</li>
<li>Learn: printk safe in IRQ, but sleep functions are not</li>
</ol>
<p><b>Learning Outcome</b>: Understand atomic vs process context.</p>
<hr  />
<p><b>Hands-On Lab 1.3</b>: Format Specifiers and Security</p>
<div class="fragment"><div class="line"><span class="comment">// lab3_format_specifiers.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab3_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> *ptr = kmalloc(100, GFP_KERNEL);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = (<span class="keywordtype">unsigned</span> long)ptr;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 3: Format Specifiers ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Basic types</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Integer: %d, Hex: 0x%x\n&quot;</span>, 42, 42);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Long: %ld, Size: %zu\n&quot;</span>, 123456789L, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Pointers (security consideration!)</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Pointer %%p (hashed): %p\n&quot;</span>, ptr);      <span class="comment">// Hashed for security</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Pointer %%px (real): %px\n&quot;</span>, ptr);      <span class="comment">// Real address (dangerous!)</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Pointer %%pK (conditional): %pK\n&quot;</span>, ptr); <span class="comment">// Depends on kptr_restrict</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Special formats</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Function: %pS\n&quot;</span>, lab3_init);           <span class="comment">// Symbol name</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;MAC: %pM\n&quot;</span>, <span class="stringliteral">&quot;\x00\x11\x22\x33\x44\x55&quot;</span>); <span class="comment">// MAC address</span></div>
<div class="line">    </div>
<div class="line">    kfree(ptr);</div>
<div class="line">    <span class="keywordflow">return</span> -EINVAL; <span class="comment">// Don&#39;t actually load</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab3_init);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>:</p><ol type="1">
<li>Load module: <code>insmod lab3_format_specifiers.ko</code></li>
<li>Compare p vs px output</li>
<li>Check <code>/proc/sys/kernel/kptr_restrict</code> value</li>
<li>Set to 0: <code>echo 0 &gt; /proc/sys/kernel/kptr_restrict</code> (see real addresses)</li>
<li>Set to 2: <code>echo 2 &gt; /proc/sys/kernel/kptr_restrict</code> (hide all)</li>
</ol>
<p><b>Learning Outcome</b>: Security implications of logging pointers.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md456"></a>
Deep Dive 2: Mastering Dynamic Debug</h2>
<p><b>Conceptual Understanding</b>:</p>
<p>Dynamic debug instruments your code at compile time but activates at runtime. How?</p>
<div class="fragment"><div class="line"><span class="comment">// Your code:</span></div>
<div class="line">pr_debug(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compiler generates (simplified):</span></div>
<div class="line"><span class="keywordflow">if</span> (unlikely(__dynamic_debug_enabled)) {</div>
<div class="line">    printk(KERN_DEBUG <span class="stringliteral">&quot;Value: %d\n&quot;</span>, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>__dynamic_debug_enabled</code> flag is controlled via sysfs!</p>
<p><b>Hands-On Lab 2.1</b>: Dynamic Debug Control</p>
<div class="fragment"><div class="line"><span class="comment">// lab4_dynamic_debug.c</span></div>
<div class="line"><span class="preprocessor">#define DEBUG  // Enable pr_debug instrumentation</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> my_function(<span class="keywordtype">int</span> value)</div>
<div class="line">{</div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;my_function called with value=%d\n&quot;</span>, value);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (value &lt; 0) {</div>
<div class="line">        pr_debug(<span class="stringliteral">&quot;Negative value detected\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -EINVAL;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;Processing value...\n&quot;</span>);</div>
<div class="line">    value *= 2;</div>
<div class="line">    </div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;Returning value=%d\n&quot;</span>, value);</div>
<div class="line">    <span class="keywordflow">return</span> value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab4_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 4: Dynamic Debug ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (i = -2; i &lt; 5; i++) {</div>
<div class="line">        <span class="keywordtype">int</span> result = my_function(i);</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;my_function(%d) = %d\n&quot;</span>, i, result);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab4_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Lab 4 cleanup\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab4_init);</div>
<div class="line">module_exit(lab4_exit);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>: </p><div class="fragment"><div class="line"># 1. Load module (no debug output yet)</div>
<div class="line">insmod lab4_dynamic_debug.ko</div>
<div class="line">dmesg | tail -20</div>
<div class="line"> </div>
<div class="line"># 2. Enable ALL debug for this module</div>
<div class="line">echo &quot;module lab4_dynamic_debug +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line"> </div>
<div class="line"># 3. Reload and see debug messages</div>
<div class="line">rmmod lab4_dynamic_debug</div>
<div class="line">insmod lab4_dynamic_debug.ko</div>
<div class="line">dmesg | tail -30  # Now see pr_debug output!</div>
<div class="line"> </div>
<div class="line"># 4. Enable only specific function</div>
<div class="line">echo &quot;module lab4_dynamic_debug -p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line">echo &quot;func my_function +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line"> </div>
<div class="line"># 5. Enable with line numbers</div>
<div class="line">echo &quot;func my_function line 8-12 +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line"> </div>
<div class="line"># 6. View current settings</div>
<div class="line">cat /sys/kernel/debug/dynamic_debug/control | grep lab4</div>
</div><!-- fragment --><p><b>Learning Outcome</b>: Control debug verbosity without recompiling.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md458"></a>
Deep Dive 3: Debugfs - Creating Debug Interfaces</h2>
<p><b>Conceptual Understanding</b>:</p>
<p>Debugfs is a RAM-based filesystem for exposing kernel data. Unlike sysfs (stable ABI), debugfs has NO stability guarantee - perfect for debugging!</p>
<p><b>Architecture</b>: </p><div class="fragment"><div class="line">/sys/kernel/debug/</div>
<div class="line">    └── mydriver/</div>
<div class="line">        ├── status      (read-only, shows driver state)</div>
<div class="line">        ├── counter     (read-write, u32 value)</div>
<div class="line">        ├── reset       (write-only, trigger action)</div>
<div class="line">        └── registers   (read-only, hardware dump)</div>
</div><!-- fragment --><p><b>Hands-On Lab 3.1</b>: Complete Debugfs Driver</p>
<div class="fragment"><div class="line"><span class="comment">// lab5_debugfs_complete.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/debugfs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/seq_file.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/slab.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Driver state</span></div>
<div class="line"><span class="keyword">struct </span>driver_state {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> counter;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> errors;</div>
<div class="line">    <span class="keywordtype">bool</span> enabled;</div>
<div class="line">    <span class="keywordtype">char</span> last_command[64];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>driver_state *state;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>dentry *debug_dir;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Simple u32 file (auto read/write)</span></div>
<div class="line"><span class="comment">// Created with: debugfs_create_u32(&quot;counter&quot;, 0644, debug_dir, &amp;state-&gt;counter);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Boolean file (auto read/write)</span></div>
<div class="line"><span class="comment">// Created with: debugfs_create_bool(&quot;enabled&quot;, 0644, debug_dir, &amp;state-&gt;enabled);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Custom read-only file (status)</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Driver Status\n&quot;</span>);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;=============\n&quot;</span>);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Counter:      %u\n&quot;</span>, state-&gt;counter);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Errors:       %u\n&quot;</span>, state-&gt;errors);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Enabled:      %s\n&quot;</span>, state-&gt;enabled ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no&quot;</span>);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Last Command: %s\n&quot;</span>, state-&gt;last_command);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> single_open(file, status_show, NULL);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations status_fops = {</div>
<div class="line">    .owner   = THIS_MODULE,</div>
<div class="line">    .open    = status_open,</div>
<div class="line">    .read    = seq_read,</div>
<div class="line">    .llseek  = seq_lseek,</div>
<div class="line">    .release = single_release,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4. Custom write-only file (control)</span></div>
<div class="line"><span class="keyword">static</span> ssize_t control_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                             <span class="keywordtype">size_t</span> count, loff_t *ppos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> cmd[64];</div>
<div class="line">    <span class="keywordtype">size_t</span> len = min(count, <span class="keyword">sizeof</span>(cmd) - 1);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(cmd, buf, len))</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    </div>
<div class="line">    cmd[len] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Remove newline</span></div>
<div class="line">    <span class="keywordflow">if</span> (len &gt; 0 &amp;&amp; cmd[len-1] == <span class="charliteral">&#39;\n&#39;</span>)</div>
<div class="line">        cmd[len-1] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    </div>
<div class="line">    strncpy(state-&gt;last_command, cmd, <span class="keyword">sizeof</span>(state-&gt;last_command) - 1);</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Control command: %s\n&quot;</span>, cmd);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(cmd, <span class="stringliteral">&quot;reset&quot;</span>) == 0) {</div>
<div class="line">        state-&gt;counter = 0;</div>
<div class="line">        state-&gt;errors = 0;</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;State reset\n&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(cmd, <span class="stringliteral">&quot;increment&quot;</span>) == 0) {</div>
<div class="line">        state-&gt;counter++;</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Counter incremented to %u\n&quot;</span>, state-&gt;counter);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(cmd, <span class="stringliteral">&quot;error&quot;</span>) == 0) {</div>
<div class="line">        state-&gt;errors++;</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Error count incremented to %u\n&quot;</span>, state-&gt;errors);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        pr_warn(<span class="stringliteral">&quot;Unknown command: %s\n&quot;</span>, cmd);</div>
<div class="line">        <span class="keywordflow">return</span> -EINVAL;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations control_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .write = control_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab5_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 5: Debugfs Complete ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Allocate state</span></div>
<div class="line">    state = kzalloc(<span class="keyword">sizeof</span>(*state), GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!state)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    state-&gt;enabled = <span class="keyword">true</span>;</div>
<div class="line">    strcpy(state-&gt;last_command, <span class="stringliteral">&quot;none&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create debugfs directory</span></div>
<div class="line">    debug_dir = debugfs_create_dir(<span class="stringliteral">&quot;lab5_driver&quot;</span>, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(debug_dir)) {</div>
<div class="line">        kfree(state);</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(debug_dir);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create files</span></div>
<div class="line">    debugfs_create_u32(<span class="stringliteral">&quot;counter&quot;</span>, 0644, debug_dir, &amp;state-&gt;counter);</div>
<div class="line">    debugfs_create_u32(<span class="stringliteral">&quot;errors&quot;</span>, 0444, debug_dir, &amp;state-&gt;errors);</div>
<div class="line">    debugfs_create_bool(<span class="stringliteral">&quot;enabled&quot;</span>, 0644, debug_dir, &amp;state-&gt;enabled);</div>
<div class="line">    debugfs_create_file(<span class="stringliteral">&quot;status&quot;</span>, 0444, debug_dir, NULL, &amp;status_fops);</div>
<div class="line">    debugfs_create_file(<span class="stringliteral">&quot;control&quot;</span>, 0200, debug_dir, NULL, &amp;control_fops);</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Debugfs interface created at /sys/kernel/debug/lab5_driver/\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab5_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    debugfs_remove_recursive(debug_dir);</div>
<div class="line">    kfree(state);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Lab 5 cleanup\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab5_init);</div>
<div class="line">module_exit(lab5_exit);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>: </p><div class="fragment"><div class="line"># 1. Load module</div>
<div class="line">insmod lab5_debugfs_complete.ko</div>
<div class="line"> </div>
<div class="line"># 2. Explore debugfs</div>
<div class="line">ls -l /sys/kernel/debug/lab5_driver/</div>
<div class="line"># Output: counter, errors, enabled, status, control</div>
<div class="line"> </div>
<div class="line"># 3. Read simple values</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/counter    # 0</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/enabled    # Y</div>
<div class="line"> </div>
<div class="line"># 4. Write simple values</div>
<div class="line">echo 42 &gt; /sys/kernel/debug/lab5_driver/counter</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/counter    # 42</div>
<div class="line"> </div>
<div class="line"># 5. Read complex status</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/status</div>
<div class="line"># Shows formatted output</div>
<div class="line"> </div>
<div class="line"># 6. Send commands</div>
<div class="line">echo &quot;increment&quot; &gt; /sys/kernel/debug/lab5_driver/control</div>
<div class="line">echo &quot;increment&quot; &gt; /sys/kernel/debug/lab5_driver/control</div>
<div class="line">echo &quot;error&quot; &gt; /sys/kernel/debug/lab5_driver/control</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/status</div>
<div class="line"> </div>
<div class="line"># 7. Reset</div>
<div class="line">echo &quot;reset&quot; &gt; /sys/kernel/debug/lab5_driver/control</div>
<div class="line">cat /sys/kernel/debug/lab5_driver/status</div>
<div class="line"> </div>
<div class="line"># 8. Check dmesg for command logs</div>
<div class="line">dmesg | tail -20</div>
</div><!-- fragment --><p><b>Learning Outcome</b>: Create production-ready debug interfaces.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md460"></a>
Deep Dive 4: Decoding Kernel Oops (Critical Skill)</h2>
<p><b>Conceptual Understanding</b>:</p>
<p>An Oops is kernel's way of saying "I crashed but didn't panic". Understanding Oops messages is CRITICAL for driver development.</p>
<p><b>Anatomy of an Oops</b>:</p>
<div class="fragment"><div class="line">BUG: unable to handle kernel NULL pointer dereference at 0000000000000000</div>
<div class="line">                    ↑                                    ↑</div>
<div class="line">                What happened                      Where (address)</div>
<div class="line"> </div>
<div class="line">IP: [&lt;ffffffffa0123456&gt;] my_function+0x12/0x34 [mymodule]</div>
<div class="line">     ↑                   ↑            ↑    ↑    ↑</div>
<div class="line">  Instruction Pointer  Function    Offset Size Module</div>
<div class="line"> </div>
<div class="line">PGD 0 </div>
<div class="line">Oops: 0002 [#1] SMP</div>
<div class="line">      ↑    ↑</div>
<div class="line">   Error  First</div>
<div class="line">   Code   Oops</div>
<div class="line"> </div>
<div class="line">CPU: 2 PID: 1234 Comm: myapp Tainted: G           O    4.19.0 #1</div>
<div class="line">     ↑        ↑         ↑              ↑           ↑</div>
<div class="line">   Which   Process   Process        Tainted    Out-of-tree</div>
<div class="line">    CPU      ID       Name           Flags       module</div>
<div class="line"> </div>
<div class="line">Call Trace:</div>
<div class="line"> another_function+0x45/0x67 [mymodule]</div>
<div class="line"> sys_ioctl+0x123/0x456</div>
<div class="line"> entry_SYSCALL_64_fastpath+0x1e/0xa3</div>
</div><!-- fragment --><p><b>Hands-On Lab 4.1</b>: Intentional NULL Dereference</p>
<div class="fragment"><div class="line"><span class="comment">// lab6_oops_null.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/slab.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> trigger_null_deref(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> *ptr = NULL;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;About to dereference NULL pointer...\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// This will cause an Oops!</span></div>
<div class="line">    *ptr = 42;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;This line will never execute\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab6_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 6: NULL Dereference Oops ===\n&quot;</span>);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;WARNING: This will crash the kernel!\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Uncomment to trigger:</span></div>
<div class="line">    <span class="comment">// trigger_null_deref();</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab6_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Lab 6 cleanup\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab6_init);</div>
<div class="line">module_exit(lab6_exit);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>: </p><div class="fragment"><div class="line"># 1. Compile with debug info</div>
<div class="line">make EXTRA_CFLAGS=&quot;-g -O0&quot;</div>
<div class="line"> </div>
<div class="line"># 2. Load module (safe, trigger commented out)</div>
<div class="line">insmod lab6_oops_null.ko</div>
<div class="line"> </div>
<div class="line"># 3. Uncomment trigger_null_deref() line, recompile</div>
<div class="line"> </div>
<div class="line"># 4. Load again (will Oops!)</div>
<div class="line">insmod lab6_oops_null.ko</div>
<div class="line"> </div>
<div class="line"># 5. Capture Oops</div>
<div class="line">dmesg &gt; oops.txt</div>
<div class="line"> </div>
<div class="line"># 6. Decode with addr2line</div>
<div class="line"># Find the offset from Oops (e.g., trigger_null_deref+0x12)</div>
<div class="line">addr2line -e lab6_oops_null.ko 0x12</div>
<div class="line"> </div>
<div class="line"># 7. Or use decode_stacktrace.sh</div>
<div class="line">./scripts/decode_stacktrace.sh vmlinux . &lt; oops.txt</div>
</div><!-- fragment --><p><b>Learning Outcome</b>: Read and decode kernel crashes.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md462"></a>
Deep Dive 5: KASAN - Memory Bug Hunter</h2>
<p><b>Conceptual Understanding</b>:</p>
<p>KASAN (Kernel Address Sanitizer) is the MOST POWERFUL memory debugging tool. It instruments EVERY memory access to detect:</p><ul>
<li>Use-after-free</li>
<li>Out-of-bounds access</li>
<li>Double-free</li>
<li>Use of uninitialized memory</li>
</ul>
<p><b>How KASAN Works</b>: </p><div class="fragment"><div class="line">Normal Memory:     [Data][Data][Data]</div>
<div class="line">With KASAN:        [Shadow][Data][Shadow][Data][Shadow]</div>
<div class="line">                      ↑                    ↑</div>
<div class="line">                   Guards detect overflow/underflow</div>
</div><!-- fragment --><p><b>Hands-On Lab 5.1</b>: KASAN Detection</p>
<div class="fragment"><div class="line"><span class="comment">// lab7_kasan.c (requires CONFIG_KASAN=y)</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/slab.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> test_use_after_free(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> *ptr = kmalloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), GFP_KERNEL);</div>
<div class="line">    </div>
<div class="line">    *ptr = 42;</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, *ptr);</div>
<div class="line">    </div>
<div class="line">    kfree(ptr);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// BUG: Use after free - KASAN will catch this!</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;After free: %d\n&quot;</span>, *ptr);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> test_out_of_bounds(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> *array = kmalloc(10 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), GFP_KERNEL);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// BUG: Out of bounds - KASAN will catch this!</span></div>
<div class="line">    array[10] = 42;</div>
<div class="line">    </div>
<div class="line">    kfree(array);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab7_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 7: KASAN Detection ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Uncomment ONE at a time:</span></div>
<div class="line">    <span class="comment">// test_use_after_free();</span></div>
<div class="line">    <span class="comment">// test_out_of_bounds();</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab7_init);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Exercise</b>: </p><div class="fragment"><div class="line"># 1. Enable KASAN in kernel config</div>
<div class="line"># CONFIG_KASAN=y</div>
<div class="line"># CONFIG_KASAN_INLINE=y</div>
<div class="line"> </div>
<div class="line"># 2. Recompile kernel (takes time!)</div>
<div class="line"> </div>
<div class="line"># 3. Boot with KASAN kernel</div>
<div class="line"> </div>
<div class="line"># 4. Load module with use-after-free</div>
<div class="line">insmod lab7_kasan.ko</div>
<div class="line"> </div>
<div class="line"># 5. Check dmesg - KASAN report:</div>
<div class="line"># ==================================================================</div>
<div class="line"># BUG: KASAN: use-after-free in test_use_after_free+0x45/0x67</div>
<div class="line"># Read of size 4 at addr ffff888012345678 by task insmod/1234</div>
<div class="line"># </div>
<div class="line"># CPU: 0 PID: 1234 Comm: insmod</div>
<div class="line"># Call Trace:</div>
<div class="line">#  dump_stack+0x...</div>
<div class="line">#  print_address_description+0x...</div>
<div class="line">#  kasan_report+0x...</div>
<div class="line">#  test_use_after_free+0x45/0x67 [lab7_kasan]</div>
<div class="line"># </div>
<div class="line"># Freed by task 1234:</div>
<div class="line">#  kfree+0x...</div>
<div class="line">#  test_use_after_free+0x38/0x67 [lab7_kasan]</div>
<div class="line"># ==================================================================</div>
</div><!-- fragment --><p><b>Learning Outcome</b>: Catch memory bugs automatically.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md464"></a>
Summary: In-Depth Learning Value</h1>
<p><b>What Learners Gain</b>:</p>
<ol type="1">
<li><b>Conceptual Understanding</b> (Not just "how" but "why")<ul>
<li>Ring buffer mechanics</li>
<li>Atomic vs process context</li>
<li>Memory instrumentation</li>
</ul>
</li>
<li><b>Hands-On Experience</b> (7 complete labs)<ul>
<li>Lab 1-3: printk mastery</li>
<li>Lab 4: Dynamic debug control</li>
<li>Lab 5: Production debugfs interface</li>
<li>Lab 6: Oops decoding</li>
<li>Lab 7: KASAN usage</li>
</ul>
</li>
<li><b>Real-World Skills</b><ul>
<li>Debug 90% of driver issues</li>
<li>Read kernel crashes</li>
<li>Create debug interfaces</li>
<li>Use advanced tools</li>
</ul>
</li>
<li><b>Time to Proficiency</b><ul>
<li>Basic (Labs 1-3): 10-15 hours → Can debug simple issues</li>
<li>Intermediate (Labs 4-5): 20-25 hours → Can debug most issues</li>
<li>Advanced (Labs 6-7): 35-45 hours → Can debug crashes and memory bugs</li>
</ul>
</li>
</ol>
<p><b>Effectiveness</b>: ⭐⭐⭐⭐⭐ (5/5)</p><ul>
<li>Combines theory + practice</li>
<li>Progressive difficulty</li>
<li>Real code examples</li>
<li>Measurable outcomes</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md466"></a>
Overview</h1>
<p>Debugging kernel drivers is challenging due to the lack of traditional debugging tools like gdb in user space (though kgdb exists for advanced use). Kernel code runs in privileged mode, so bugs can cause system crashes, panics, or subtle race conditions. This chapter covers various techniques and tools for debugging Linux device drivers, emphasizing non-intrusive methods to avoid altering timing-sensitive behavior.</p>
<p><b>Deeper Insight</b>: Kernel debugging often relies on instrumentation (e.g., logs) because stopping execution (breakpoints) can disrupt real-time operations or hardware interactions. Tools like ftrace or perf add runtime overhead but provide visibility into call stacks and events. Always compile the kernel with <code>CONFIG_DEBUG_KERNEL=y</code> to enable these features.</p>
<p><b>Potential Pitfalls</b>: Overusing logs can flood the console and hide critical messages. Use rate-limiting (e.g., <code>pr_info_ratelimited</code>) in high-frequency paths.</p>
<h1><a class="anchor" id="autotoc_md467"></a>
printk Debugging</h1>
<h2><a class="anchor" id="autotoc_md468"></a>
Terminology for This Section</h2>
<p><b>printk</b>: Kernel's printf function for logging messages <b>dmesg</b>: Command to read kernel log messages <b>Log Level</b>: Priority of message (0=emergency, 7=debug) <b>Console</b>: Screen where kernel messages appear <b>Ring Buffer</b>: Circular memory storing log messages</p>
<h2><a class="anchor" id="autotoc_md469"></a>
Concept Overview</h2>
<div class="dotgraph">
<img src="dot_inline_dotgraph_4.png" alt="dot_inline_dotgraph_4.png" border="0" usemap="#dot_inline_dotgraph_4.map"/>
</div>
<h2><a class="anchor" id="autotoc_md470"></a>
How printk Works Internally</h2>
<div class="dotgraph">
<img src="dot_inline_dotgraph_5.png" alt="dot_inline_dotgraph_5.png" border="0" usemap="#dot_inline_dotgraph_5.map"/>
</div>
<h2><a class="anchor" id="autotoc_md471"></a>
Basic Usage</h2>
<p><code>printk</code> is the kernel's equivalent of <code>printf</code>, but it's asynchronous and thread-safe. Messages are stored in a ring buffer and can be viewed via <code>dmesg</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line">printk(KERN_INFO <span class="stringliteral">&quot;Driver loaded\n&quot;</span>);</div>
<div class="line">printk(KERN_DEBUG <span class="stringliteral">&quot;Value: %d\n&quot;</span>, value);</div>
<div class="line">printk(KERN_ERR <span class="stringliteral">&quot;Error occurred: %d\n&quot;</span>, error);</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: <code>printk</code> uses a lockless ring buffer (<code>log_buf</code>) to store messages. It supports format specifiers like <code>p</code> for pointers (with hashing for security via <code>pK</code>). In atomic contexts (e.g., interrupts), it defers printing to a kthread. For high-throughput, consider <code>netconsole</code> to offload logs over network.</p>
<p><b>Advanced Usage</b>: Use <code>printk_deferred</code> to avoid console locking in sensitive paths. For timestamps, enable <code>CONFIG_PRINTK_TIME=y</code>.</p>
<h2><a class="anchor" id="autotoc_md472"></a>
Log Levels</h2>
<p>Log levels determine message priority and visibility. Lower numbers are higher priority.</p>
<p><b>Terminology</b>:</p><ul>
<li><b>Log Level</b>: Number indicating message importance (0-7)</li>
<li><b>Console Log Level</b>: Minimum priority shown on screen</li>
<li><b>Default Log Level</b>: Level used if you don't specify one</li>
</ul>
<p><b>Visual Priority Scale</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_6.png" alt="dot_inline_dotgraph_6.png" border="0" usemap="#dot_inline_dotgraph_6.map"/>
</div>
<p><b>How Log Level Filtering Works</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_7.png" alt="dot_inline_dotgraph_7.png" border="0" usemap="#dot_inline_dotgraph_7.map"/>
</div>
<div class="fragment"><div class="line">KERN_EMERG      <span class="stringliteral">&quot;&lt;0&gt;&quot;</span>  <span class="comment">// System is unusable (e.g., hardware failure)</span></div>
<div class="line">KERN_ALERT      <span class="stringliteral">&quot;&lt;1&gt;&quot;</span>  <span class="comment">// Action must be taken immediately (e.g., OOM killer active)</span></div>
<div class="line">KERN_CRIT       <span class="stringliteral">&quot;&lt;2&gt;&quot;</span>  <span class="comment">// Critical conditions (e.g., filesystem corruption)</span></div>
<div class="line">KERN_ERR        <span class="stringliteral">&quot;&lt;3&gt;&quot;</span>  <span class="comment">// Error conditions (e.g., I/O failure)</span></div>
<div class="line">KERN_WARNING    <span class="stringliteral">&quot;&lt;4&gt;&quot;</span>  <span class="comment">// Warning conditions (e.g., deprecated API use)</span></div>
<div class="line">KERN_NOTICE     <span class="stringliteral">&quot;&lt;5&gt;&quot;</span>  <span class="comment">// Normal but significant (e.g., device hotplug)</span></div>
<div class="line">KERN_INFO       <span class="stringliteral">&quot;&lt;6&gt;&quot;</span>  <span class="comment">// Informational (e.g., module load)</span></div>
<div class="line">KERN_DEBUG      <span class="stringliteral">&quot;&lt;7&gt;&quot;</span>  <span class="comment">// Debug-level messages (requires CONFIG_DEBUG)</span></div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Levels are filtered by <code>/proc/sys/kernel/printk</code> (e.g., <code>4 4 1 7</code> means console loglevel=4, default=4, min=1, warning=7). Use <code>echo 8 &gt; /proc/sys/kernel/printk</code> to see all debug messages.</p>
<p><b>Understanding /proc/sys/kernel/printk</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_8.png" alt="dot_inline_dotgraph_8.png" border="0" usemap="#dot_inline_dotgraph_8.map"/>
</div>
<p><b>Block Diagram: printk Flow</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_9.png" alt="dot_inline_dotgraph_9.png" border="0" usemap="#dot_inline_dotgraph_9.map"/>
</div>
<h2><a class="anchor" id="autotoc_md473"></a>
Viewing Messages</h2>
<div class="fragment"><div class="line"># View kernel messages</div>
<div class="line">dmesg  # Shows entire buffer with timestamps</div>
<div class="line"> </div>
<div class="line"># Follow messages (real-time tail)</div>
<div class="line">dmesg -w</div>
<div class="line"> </div>
<div class="line"># Filter by level</div>
<div class="line">dmesg -l err  # Only errors</div>
<div class="line"> </div>
<div class="line"># Clear buffer</div>
<div class="line">dmesg -c  # Clears after displaying</div>
<div class="line"> </div>
<div class="line"># With systemd</div>
<div class="line">journalctl -k  # Kernel messages only</div>
<div class="line">journalctl -kf  # Follow kernel messages</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: <code>dmesg</code> reads from <code>/dev/kmsg</code> or the ring buffer. For large buffers, configure <code>CONFIG_LOG_BUF_SHIFT=18</code> (256KB). In embedded systems, use <code>netconsole</code> for remote logging: <code>modprobe netconsole netconsole=6666@192.168.1.2/eth0,6666@192.168.1.3/</code>.</p>
<h2><a class="anchor" id="autotoc_md474"></a>
Dynamic Debug</h2>
<p>Dynamic debug allows runtime control of debug messages without recompiling.</p>
<div class="fragment"><div class="line"><span class="comment">// Enable at compile time</span></div>
<div class="line"><span class="preprocessor">#define DEBUG</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use pr_debug</span></div>
<div class="line">pr_debug(<span class="stringliteral">&quot;Debug message: %d\n&quot;</span>, value);</div>
</div><!-- fragment --><p>Enable at runtime: </p><div class="fragment"><div class="line"># Enable all debug messages for module</div>
<div class="line">echo &quot;module mymodule +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control  # +p: print</div>
<div class="line"> </div>
<div class="line"># Enable for specific file</div>
<div class="line">echo &quot;file mydriver.c +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line"> </div>
<div class="line"># Enable for specific function and line</div>
<div class="line">echo &quot;func my_function line 100-200 +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
<div class="line"> </div>
<div class="line"># Disable</div>
<div class="line">echo &quot;module mymodule -p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: This uses <code>dyndbg</code> queries on <code>/sys/kernel/debug/dynamic_debug/control</code>. It instruments <code>pr_debug</code> calls at compile time with no-ops unless enabled. For performance, use <code>CONFIG_DYNAMIC_DEBUG=y</code>. Combine with ftrace for function-level tracing.</p>
<p><b>Block Diagram: Dynamic Debug Control Flow</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_10.png" alt="dot_inline_dotgraph_10.png" border="0" usemap="#dot_inline_dotgraph_10.map"/>
</div>
<h1><a class="anchor" id="autotoc_md475"></a>
pr_* Macros</h1>
<p>Preferred over raw <code>printk</code> for consistency and device context.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/printk.h&gt;</span></div>
<div class="line"> </div>
<div class="line">pr_emerg(<span class="stringliteral">&quot;Emergency message\n&quot;</span>);   <span class="comment">// Highest priority</span></div>
<div class="line">pr_alert(<span class="stringliteral">&quot;Alert message\n&quot;</span>);</div>
<div class="line">pr_crit(<span class="stringliteral">&quot;Critical message\n&quot;</span>);</div>
<div class="line">pr_err(<span class="stringliteral">&quot;Error message\n&quot;</span>);</div>
<div class="line">pr_warning(<span class="stringliteral">&quot;Warning message\n&quot;</span>);</div>
<div class="line">pr_notice(<span class="stringliteral">&quot;Notice message\n&quot;</span>);</div>
<div class="line">pr_info(<span class="stringliteral">&quot;Info message\n&quot;</span>);</div>
<div class="line">pr_debug(<span class="stringliteral">&quot;Debug message\n&quot;</span>);       <span class="comment">// Requires DEBUG</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// With device context (adds device name)</span></div>
<div class="line">dev_err(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Device error\n&quot;</span>);</div>
<div class="line">dev_warn(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Device warning\n&quot;</span>);</div>
<div class="line">dev_info(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Device info\n&quot;</span>);</div>
<div class="line">dev_dbg(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Device debug\n&quot;</span>);</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: These macros expand to <code>printk</code> with predefined levels. <code>dev_*</code> variants use <code>dev_fmt</code> to prefix with device info (e.g., "[0000:01:00.0] Error"). For rate-limiting: <code>dev_info_ratelimited(&amp;dev, "Message");</code> (limits to 1/sec by default).</p>
<p><b>Advanced</b>: In drivers, prefer <code>dev_*</code> for traceability. For dynamic debug, <code>dev_dbg</code> integrates with dyndbg.</p>
<h1><a class="anchor" id="autotoc_md476"></a>
Debugfs</h1>
<h2><a class="anchor" id="autotoc_md477"></a>
Terminology for This Section</h2>
<p><b>Debugfs</b>: Virtual filesystem for debugging (like a folder in /sys/kernel/debug/) <b>Virtual Filesystem</b>: Filesystem that exists only in RAM, not on disk <b>dentry</b>: Directory entry (represents a file or folder) <b>seq_file</b>: Sequential file interface for generating output on-the-fly <b>file_operations</b>: Structure defining how to read/write a file</p>
<h2><a class="anchor" id="autotoc_md478"></a>
Concept Overview</h2>
<p>Debugfs is a RAM-based filesystem for exposing kernel data. Unlike sysfs (stable ABI), debugfs has NO stability guarantee - perfect for debugging!</p>
<p><b>What is a Virtual Filesystem?</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_11.png" alt="dot_inline_dotgraph_11.png" border="0" usemap="#dot_inline_dotgraph_11.map"/>
</div>
<p><b>Debugfs Architecture</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_12.png" alt="dot_inline_dotgraph_12.png" border="0" usemap="#dot_inline_dotgraph_12.map"/>
</div>
<p><b>Debugfs File Types</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_13.png" alt="dot_inline_dotgraph_13.png" border="0" usemap="#dot_inline_dotgraph_13.map"/>
</div>
<p>Debugfs is a virtual filesystem (/sys/kernel/debug/) for exposing kernel data in a flexible, non-permanent way. It's for debugging only—not for production APIs.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/debugfs.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>dentry *debug_dir;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> debug_value = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init debug_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create directory (parent can be NULL for root)</span></div>
<div class="line">    debug_dir = debugfs_create_dir(<span class="stringliteral">&quot;mydriver&quot;</span>, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (!debug_dir)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a u32 file (mode 0644: owner rw, group/others r)</span></div>
<div class="line">    debugfs_create_u32(<span class="stringliteral">&quot;value&quot;</span>, 0644, debug_dir, &amp;debug_value);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit debug_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Recursively remove directory and contents</span></div>
<div class="line">    debugfs_remove_recursive(debug_dir);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: Debugfs uses ramfs backend, so it's in-memory and fast. Files are created with helpers like <code>debugfs_create_u32</code>, which handle read/write ops internally. Custom files need <code>file_operations</code>. Unlike sysfs, debugfs has no ABI stability—it's debug-only.</p>
<p><b>Performance Note</b>: Reading large data? Use <code>seq_file</code> for efficient iteration (avoids large buffers).</p>
<h2><a class="anchor" id="autotoc_md479"></a>
Debugfs File Types</h2>
<p>Debugfs provides convenience functions for common types:</p>
<div class="fragment"><div class="line"><span class="comment">// Integer types (automatically handle read/write as strings)</span></div>
<div class="line">debugfs_create_u8(name, mode, parent, value);   <span class="comment">// 8-bit unsigned</span></div>
<div class="line">debugfs_create_u16(name, mode, parent, value);  <span class="comment">// 16-bit</span></div>
<div class="line">debugfs_create_u32(name, mode, parent, value);  <span class="comment">// 32-bit (most common)</span></div>
<div class="line">debugfs_create_u64(name, mode, parent, value);  <span class="comment">// 64-bit</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Boolean (reads as 0/1, writes y/n/1/0)</span></div>
<div class="line">debugfs_create_bool(name, mode, parent, value);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Blob (binary data, e.g., for dumping registers)</span></div>
<div class="line">debugfs_create_blob(name, mode, parent, blob);  <span class="comment">// struct debugfs_blob_wrapper</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom file with file_operations</span></div>
<div class="line"><span class="keyword">struct </span>dentry *debugfs_create_file(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, umode_t mode,</div>
<div class="line">                                   <span class="keyword">struct</span> dentry *parent, <span class="keywordtype">void</span> *data,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *fops);</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: For blobs, wrap data in <code>struct debugfs_blob_wrapper { void *data; unsigned long size; };</code>. Modes follow POSIX (e.g., 0444 for read-only).</p>
<h2><a class="anchor" id="autotoc_md480"></a>
Seq_file for Sequential Output</h2>
<p>For files that generate data on-the-fly (e.g., status dumps), use <code>seq_file</code> to avoid buffering large outputs.</p>
<p><b>Terminology</b>:</p><ul>
<li><b>seq_file</b>: Interface for generating large output sequentially</li>
<li><b>single_open</b>: Simple seq_file for single-read files</li>
<li><b>seq_printf</b>: Like printf but for seq_file</li>
<li><b>seq_puts</b>: Like puts but for seq_file (faster for strings)</li>
</ul>
<p><b>Why seq_file?</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_14.png" alt="dot_inline_dotgraph_14.png" border="0" usemap="#dot_inline_dotgraph_14.map"/>
</div>
<p><b>seq_file Flow</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_15.png" alt="dot_inline_dotgraph_15.png" border="0" usemap="#dot_inline_dotgraph_15.map"/>
</div>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/seq_file.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Counter: %d\n&quot;</span>, info.counter);  <span class="comment">// Like fprintf</span></div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Errors: %d\n&quot;</span>, info.errors);</div>
<div class="line">    seq_puts(m, <span class="stringliteral">&quot;Status: OK\n&quot;</span>);                   <span class="comment">// Faster for strings</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;                                      <span class="comment">// 0 means success</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> single_open(file, status_show, NULL);   <span class="comment">// For single-read files</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations status_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = status_open,</div>
<div class="line">    .read = seq_read,     <span class="comment">// Provided by seq_file</span></div>
<div class="line">    .llseek = seq_lseek,  <span class="comment">// Supports seeking</span></div>
<div class="line">    .release = single_release,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In init: debugfs_create_file(&quot;status&quot;, 0444, debug_dir, NULL, &amp;status_fops);</span></div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: <code>seq_file</code> uses a virtual buffer, calling <code>show</code> only when reading. For multi-page outputs, implement iterators with <code>start/next/stop</code>. This prevents OOM in large dumps.</p>
<h2><a class="anchor" id="autotoc_md481"></a>
Custom Write Operations</h2>
<p>For writable files:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> ssize_t reset_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                           <span class="keywordtype">size_t</span> count, loff_t *ppos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> cmd[16];</div>
<div class="line">    <span class="keywordflow">if</span> (count &gt;= <span class="keyword">sizeof</span>(cmd)) <span class="keywordflow">return</span> -EINVAL;  <span class="comment">// Bounds check</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(cmd, buf, count)) <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (strncmp(cmd, <span class="stringliteral">&quot;reset&quot;</span>, 5) == 0) {       <span class="comment">// Parse input</span></div>
<div class="line">        info.counter = 0;</div>
<div class="line">        info.errors = 0;</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Debug info reset\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> count;  <span class="comment">// Return bytes written (success)</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations reset_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .write = reset_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// debugfs_create_file(&quot;reset&quot;, 0200, debug_dir, NULL, &amp;reset_fops);  // Write-only</span></div>
</div><!-- fragment --><p><b>Advanced</b>: Validate input strictly to avoid buffer overflows. Use <code>kstrtoint</code> for numeric parsing.</p>
<h2><a class="anchor" id="autotoc_md482"></a>
Complete Debugfs Example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/debugfs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/seq_file.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>debug_info {</div>
<div class="line">    <span class="keywordtype">int</span> counter;</div>
<div class="line">    <span class="keywordtype">int</span> errors;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> last_access;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>debug_info info = {0};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>dentry *debug_dir;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Counter: %d\n&quot;</span>, info.counter);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Errors: %d\n&quot;</span>, info.errors);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Last access: %lu\n&quot;</span>, info.last_access);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> status_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> single_open(file, status_show, NULL);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations status_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = status_open,</div>
<div class="line">    .read = seq_read,</div>
<div class="line">    .llseek = seq_lseek,</div>
<div class="line">    .release = single_release,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t reset_write(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *ppos)</div>
<div class="line">{</div>
<div class="line">    info.counter = 0;</div>
<div class="line">    info.errors = 0;</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Debug info reset\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>file_operations reset_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .write = reset_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init debug_example_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    debug_dir = debugfs_create_dir(<span class="stringliteral">&quot;mydriver&quot;</span>, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(debug_dir))</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(debug_dir);</div>
<div class="line">    </div>
<div class="line">    debugfs_create_file(<span class="stringliteral">&quot;status&quot;</span>, 0444, debug_dir, NULL, &amp;status_fops);</div>
<div class="line">    debugfs_create_file(<span class="stringliteral">&quot;reset&quot;</span>, 0200, debug_dir, NULL, &amp;reset_fops);</div>
<div class="line">    debugfs_create_u32(<span class="stringliteral">&quot;counter&quot;</span>, 0644, debug_dir, &amp;info.counter);</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Debug interface created\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit debug_example_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    debugfs_remove_recursive(debug_dir);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Debug interface removed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(debug_example_init);</div>
<div class="line">module_exit(debug_example_exit);</div>
<div class="line"> </div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
<div class="line">MODULE_DESCRIPTION(<span class="stringliteral">&quot;Debugging example&quot;</span>);</div>
</div><!-- fragment --><p><b>Block Diagram: Debugfs Structure</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_16.png" alt="dot_inline_dotgraph_16.png" border="0" usemap="#dot_inline_dotgraph_16.map"/>
</div>
<h2><a class="anchor" id="autotoc_md483"></a>
Accessing Debugfs</h2>
<div class="fragment"><div class="line"># Mount debugfs (usually auto-mounted)</div>
<div class="line">mount -t debugfs none /sys/kernel/debug</div>
<div class="line"> </div>
<div class="line"># Read value</div>
<div class="line">cat /sys/kernel/debug/mydriver/value</div>
<div class="line"> </div>
<div class="line"># Write value</div>
<div class="line">echo 42 &gt; /sys/kernel/debug/mydriver/value</div>
<div class="line"> </div>
<div class="line"># View status</div>
<div class="line">cat /sys/kernel/debug/mydriver/status</div>
<div class="line"> </div>
<div class="line"># Reset counters</div>
<div class="line">echo reset &gt; /sys/kernel/debug/mydriver/reset</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md484"></a>
ftrace (Function Tracer)</h1>
<p>ftrace is a powerful kernel tracing framework for debugging function calls, latencies, and kernel events.</p>
<p><b>Configuration</b>: Enable <code>CONFIG_FTRACE=y</code>, <code>CONFIG_FUNCTION_TRACER=y</code>, <code>CONFIG_FUNCTION_GRAPH_TRACER=y</code>.</p>
<h2><a class="anchor" id="autotoc_md485"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"># Mount tracefs (usually at /sys/kernel/tracing or /sys/kernel/debug/tracing)</div>
<div class="line">mount -t tracefs nodev /sys/kernel/tracing</div>
<div class="line"> </div>
<div class="line"># View available tracers</div>
<div class="line">cat /sys/kernel/tracing/available_tracers</div>
<div class="line"> </div>
<div class="line"># Set function tracer</div>
<div class="line">echo function &gt; /sys/kernel/tracing/current_tracer</div>
<div class="line"> </div>
<div class="line"># Trace specific function</div>
<div class="line">echo my_function &gt; /sys/kernel/tracing/set_ftrace_filter</div>
<div class="line"> </div>
<div class="line"># Start tracing</div>
<div class="line">echo 1 &gt; /sys/kernel/tracing/tracing_on</div>
<div class="line"> </div>
<div class="line"># Run your code...</div>
<div class="line"> </div>
<div class="line"># Stop tracing</div>
<div class="line">echo 0 &gt; /sys/kernel/tracing/tracing_on</div>
<div class="line"> </div>
<div class="line"># View trace</div>
<div class="line">cat /sys/kernel/tracing/trace</div>
<div class="line"> </div>
<div class="line"># Clear trace buffer</div>
<div class="line">echo &gt; /sys/kernel/tracing/trace</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md486"></a>
Function Graph Tracer</h2>
<p>Shows call graphs with entry/exit times:</p>
<div class="fragment"><div class="line"># Enable function graph tracer</div>
<div class="line">echo function_graph &gt; /sys/kernel/tracing/current_tracer</div>
<div class="line"> </div>
<div class="line"># Trace specific module functions</div>
<div class="line">echo &#39;:mod:mymodule&#39; &gt; /sys/kernel/tracing/set_ftrace_filter</div>
<div class="line"> </div>
<div class="line"># Set graph depth (avoid deep recursion)</div>
<div class="line">echo 5 &gt; /sys/kernel/tracing/max_graph_depth</div>
<div class="line"> </div>
<div class="line"># Enable tracing</div>
<div class="line">echo 1 &gt; /sys/kernel/tracing/tracing_on</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Function graph shows execution time per function, useful for performance analysis. Supports filtering by PID: <code>echo $PID &gt; /sys/kernel/tracing/set_ftrace_pid</code>.</p>
<h2><a class="anchor" id="autotoc_md487"></a>
Trace Events</h2>
<p>Enable predefined kernel events:</p>
<div class="fragment"><div class="line"># List available events</div>
<div class="line">cat /sys/kernel/tracing/available_events</div>
<div class="line"> </div>
<div class="line"># Enable specific event</div>
<div class="line">echo 1 &gt; /sys/kernel/tracing/events/sched/sched_switch/enable</div>
<div class="line"> </div>
<div class="line"># Enable all events in subsystem</div>
<div class="line">echo 1 &gt; /sys/kernel/tracing/events/irq/enable</div>
<div class="line"> </div>
<div class="line"># View event format</div>
<div class="line">cat /sys/kernel/tracing/events/sched/sched_switch/format</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md488"></a>
Using trace-cmd</h2>
<p>User-friendly wrapper for ftrace:</p>
<div class="fragment"><div class="line"># Record function trace</div>
<div class="line">trace-cmd record -p function -g my_function</div>
<div class="line"> </div>
<div class="line"># Record with events</div>
<div class="line">trace-cmd record -e sched -e irq</div>
<div class="line"> </div>
<div class="line"># View report</div>
<div class="line">trace-cmd report</div>
<div class="line"> </div>
<div class="line"># Live trace</div>
<div class="line">trace-cmd start -p function_graph</div>
<div class="line">trace-cmd show</div>
<div class="line">trace-cmd stop</div>
</div><!-- fragment --><p><b>Advanced</b>: Use <code>trace-cmd</code> with <code>-F</code> to trace specific commands: <code>trace-cmd record -F ./myapp</code>.</p>
<p><b>Block Diagram: ftrace Workflow</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_17.png" alt="dot_inline_dotgraph_17.png" border="0" usemap="#dot_inline_dotgraph_17.map"/>
</div>
<h1><a class="anchor" id="autotoc_md489"></a>
KGDB (Kernel Debugger)</h1>
<p>KGDB enables interactive debugging of the kernel using GDB over serial or network.</p>
<h2><a class="anchor" id="autotoc_md490"></a>
Setup</h2>
<p>Kernel configuration: </p><div class="fragment"><div class="line">CONFIG_KGDB=y</div>
<div class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</div>
<div class="line">CONFIG_FRAME_POINTER=y</div>
<div class="line">CONFIG_DEBUG_INFO=y</div>
</div><!-- fragment --><p>Boot parameters: </p><div class="fragment"><div class="line"># Wait for debugger at boot</div>
<div class="line">kgdboc=ttyS0,115200 kgdbwait</div>
<div class="line"> </div>
<div class="line"># Or trigger later via SysRq</div>
<div class="line">kgdboc=ttyS0,115200</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md491"></a>
Usage</h2>
<p>On target system: </p><div class="fragment"><div class="line"># Trigger debugger via SysRq</div>
<div class="line">echo g &gt; /proc/sysrq-trigger</div>
<div class="line"> </div>
<div class="line"># Or from kernel code</div>
<div class="line">#include &lt;linux/kgdb.h&gt;</div>
<div class="line">kgdb_breakpoint();</div>
</div><!-- fragment --><p>On host system: </p><div class="fragment"><div class="line"># Connect with GDB</div>
<div class="line">gdb vmlinux</div>
<div class="line">(gdb) set serial baud 115200</div>
<div class="line">(gdb) target remote /dev/ttyS0</div>
<div class="line"> </div>
<div class="line"># Set breakpoints</div>
<div class="line">(gdb) break my_function</div>
<div class="line">(gdb) break mydriver.c:123</div>
<div class="line"> </div>
<div class="line"># Continue execution</div>
<div class="line">(gdb) continue</div>
<div class="line"> </div>
<div class="line"># Examine variables</div>
<div class="line">(gdb) print my_variable</div>
<div class="line">(gdb) print *my_struct</div>
<div class="line"> </div>
<div class="line"># Backtrace</div>
<div class="line">(gdb) bt</div>
<div class="line"> </div>
<div class="line"># Step through code</div>
<div class="line">(gdb) step</div>
<div class="line">(gdb) next</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: KGDB pauses all CPUs when hitting a breakpoint. Use with QEMU for safe testing: <code>qemu-system-x86_64 -s -S -kernel bzImage -append "kgdboc=ttyS0,115200 kgdbwait"</code>. Connect with <code>target remote :1234</code>.</p>
<p><b>Limitations</b>: Cannot debug early boot without kgdbwait. Hardware breakpoints limited by CPU (typically 4 on x86).</p>
<h1><a class="anchor" id="autotoc_md492"></a>
Oops and Panic Analysis</h1>
<h2><a class="anchor" id="autotoc_md493"></a>
Understanding Oops Messages</h2>
<p>An Oops indicates a kernel bug but may allow continued operation (unlike panic).</p>
<p>Example Oops: </p><div class="fragment"><div class="line">BUG: unable to handle kernel NULL pointer dereference at 0000000000000000</div>
<div class="line">IP: [&lt;ffffffffa0123456&gt;] my_function+0x12/0x34 [mymodule]</div>
<div class="line">PGD 0 </div>
<div class="line">Oops: 0002 [#1] SMP</div>
<div class="line">CPU: 2 PID: 1234 Comm: myapp Tainted: G           O    4.19.0 #1</div>
<div class="line">RIP: 0010:my_function+0x12/0x34 [mymodule]</div>
<div class="line">Call Trace:</div>
<div class="line"> another_function+0x45/0x67 [mymodule]</div>
<div class="line"> sys_ioctl+0x123/0x456</div>
<div class="line"> entry_SYSCALL_64_fastpath+0x1e/0xa3</div>
</div><!-- fragment --><p><b>Decoding</b>:</p><ul>
<li><code>IP</code>: Instruction pointer (where crash occurred)</li>
<li><code>+0x12/0x34</code>: Offset 0x12 bytes into function (size 0x34)</li>
<li><code>Tainted: G O</code>: G=proprietary module loaded, O=out-of-tree module</li>
<li><code>Call Trace</code>: Stack backtrace</li>
</ul>
<h2><a class="anchor" id="autotoc_md494"></a>
Decoding Addresses</h2>
<div class="fragment"><div class="line"># Using addr2line</div>
<div class="line">addr2line -e mymodule.ko 0x12</div>
<div class="line"> </div>
<div class="line"># Using scripts/decode_stacktrace.sh</div>
<div class="line">./scripts/decode_stacktrace.sh vmlinux /path/to/modules &lt; oops.txt</div>
<div class="line"> </div>
<div class="line"># Using gdb</div>
<div class="line">gdb vmlinux</div>
<div class="line">(gdb) list *(my_function+0x12)</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: For modules, use <code>cat /proc/modules</code> to find load address, then calculate: <code>module_base + offset</code>. Enable <code>CONFIG_DEBUG_INFO=y</code> for line numbers.</p>
<h2><a class="anchor" id="autotoc_md495"></a>
Kernel Panic</h2>
<p>Panic halts the system. Configure behavior:</p>
<div class="fragment"><div class="line"># Reboot after panic (seconds)</div>
<div class="line">echo 10 &gt; /proc/sys/kernel/panic</div>
<div class="line"> </div>
<div class="line"># Panic on oops</div>
<div class="line">echo 1 &gt; /proc/sys/kernel/panic_on_oops</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md496"></a>
Memory Debugging</h1>
<h2><a class="anchor" id="autotoc_md497"></a>
Terminology for This Section</h2>
<p><b>KASAN</b>: Kernel Address Sanitizer - detects memory bugs <b>Use-after-free</b>: Accessing memory after it's been freed (BUG!) <b>Out-of-bounds</b>: Accessing array beyond its size (BUG!) <b>Memory leak</b>: Allocating memory but never freeing it <b>Shadow memory</b>: Extra memory KASAN uses to track allocations <b>SLUB</b>: Kernel's memory allocator (like malloc for kernel) <b>Slab</b>: Chunk of memory for specific object type</p>
<h2><a class="anchor" id="autotoc_md498"></a>
Memory Bug Types Explained</h2>
<div class="dotgraph">
<img src="dot_inline_dotgraph_18.png" alt="dot_inline_dotgraph_18.png" border="0" usemap="#dot_inline_dotgraph_18.map"/>
</div>
<h2><a class="anchor" id="autotoc_md499"></a>
KASAN (Kernel Address Sanitizer)</h2>
<p>Detects use-after-free, out-of-bounds, and other memory errors.</p>
<p><b>How KASAN Works</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_19.png" alt="dot_inline_dotgraph_19.png" border="0" usemap="#dot_inline_dotgraph_19.map"/>
</div>
<p><b>KASAN Detection Process</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_20.png" alt="dot_inline_dotgraph_20.png" border="0" usemap="#dot_inline_dotgraph_20.map"/>
</div>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_KASAN=y</div>
<div class="line">CONFIG_KASAN_INLINE=y  # Faster but larger</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: KASAN instruments all memory accesses, adding shadow memory (1/8 of RAM). Reports include stack traces. For embedded, use <code>CONFIG_KASAN_OUTLINE=y</code> (smaller but slower).</p>
<p>Example output: </p><div class="fragment"><div class="line">BUG: KASAN: use-after-free in my_function+0x12/0x34</div>
<div class="line">Read of size 4 at addr ffff888012345678 by task myapp/1234</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md500"></a>
SLUB Debug</h2>
<p>Debug slab allocator issues.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_SLUB_DEBUG=y</div>
</div><!-- fragment --><p>Boot parameters: </p><div class="fragment"><div class="line"># Enable all checks</div>
<div class="line">slub_debug=FZPU</div>
<div class="line"> </div>
<div class="line"># F: Sanity checks</div>
<div class="line"># Z: Red zoning</div>
<div class="line"># P: Poisoning</div>
<div class="line"># U: User tracking</div>
</div><!-- fragment --><p>Runtime: </p><div class="fragment"><div class="line"># Validate specific cache</div>
<div class="line">echo 1 &gt; /sys/kernel/slab/kmalloc-64/validate</div>
<div class="line"> </div>
<div class="line"># Show allocation traces</div>
<div class="line">cat /sys/kernel/slab/kmalloc-64/alloc_calls</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Red zoning adds guard bytes around allocations. Poisoning fills freed memory with 0x6b pattern. Use for detecting overflows and use-after-free.</p>
<h2><a class="anchor" id="autotoc_md501"></a>
Kmemleak</h2>
<p>Detects memory leaks in kernel.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_DEBUG_KMEMLEAK=y</div>
</div><!-- fragment --><p>Usage: </p><div class="fragment"><div class="line"># Trigger scan</div>
<div class="line">echo scan &gt; /sys/kernel/debug/kmemleak</div>
<div class="line"> </div>
<div class="line"># View leaks</div>
<div class="line">cat /sys/kernel/debug/kmemleak</div>
<div class="line"> </div>
<div class="line"># Clear reported leaks</div>
<div class="line">echo clear &gt; /sys/kernel/debug/kmemleak</div>
<div class="line"> </div>
<div class="line"># Disable scanning</div>
<div class="line">echo off &gt; /sys/kernel/debug/kmemleak</div>
</div><!-- fragment --><p><b>Deeper Explanation</b>: Kmemleak scans memory for pointers to allocated objects. Unreferenced objects are reported as leaks. False positives occur if pointers stored in hardware registers or obfuscated.</p>
<h1><a class="anchor" id="autotoc_md502"></a>
Lock Debugging</h1>
<h2><a class="anchor" id="autotoc_md503"></a>
Lockdep</h2>
<p>Detects deadlocks, lock inversions, and circular dependencies.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_PROVE_LOCKING=y</div>
<div class="line">CONFIG_DEBUG_LOCK_ALLOC=y</div>
<div class="line">CONFIG_DEBUG_LOCKDEP=y</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Lockdep tracks lock acquisition order across all code paths. Reports potential deadlocks even if not triggered. Adds ~10% overhead.</p>
<p>Example output: </p><div class="fragment"><div class="line">WARNING: possible circular locking dependency detected</div>
<div class="line">CPU0                    CPU1</div>
<div class="line">----                    ----</div>
<div class="line">lock(A);</div>
<div class="line">                        lock(B);</div>
<div class="line">                        lock(A);</div>
<div class="line">lock(B);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md504"></a>
Lock Statistics</h2>
<p>Measure lock contention.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_LOCK_STAT=y</div>
</div><!-- fragment --><p>Usage: </p><div class="fragment"><div class="line"># Enable statistics</div>
<div class="line">echo 1 &gt; /proc/sys/kernel/lock_stat</div>
<div class="line"> </div>
<div class="line"># View stats</div>
<div class="line">cat /proc/lock_stat</div>
<div class="line"> </div>
<div class="line"># Reset stats</div>
<div class="line">echo 0 &gt; /proc/lock_stat</div>
</div><!-- fragment --><p><b>Advanced</b>: Identify hot locks causing contention. Consider RCU or per-CPU variables to reduce locking.</p>
<h1><a class="anchor" id="autotoc_md505"></a>
Magic SysRq</h1>
<p>Emergency debugging and recovery keys.</p>
<h2><a class="anchor" id="autotoc_md506"></a>
Setup</h2>
<div class="fragment"><div class="line"># Enable all SysRq functions</div>
<div class="line">echo 1 &gt; /proc/sys/kernel/sysrq</div>
<div class="line"> </div>
<div class="line"># Or specific functions (bitmask)</div>
<div class="line"># 1: Enable all, 0: Disable all</div>
<div class="line"># 2: Console logging, 4: Keyboard, 8: Process signals, etc.</div>
<div class="line">echo 438 &gt; /proc/sys/kernel/sysrq  # Common safe subset</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md507"></a>
Usage</h2>
<p>Via keyboard: </p><div class="fragment"><div class="line">Alt + SysRq + &lt;key&gt;</div>
</div><!-- fragment --><p>Via /proc: </p><div class="fragment"><div class="line">echo &lt;key&gt; &gt; /proc/sysrq-trigger</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md508"></a>
Useful Keys</h2>
<div class="fragment"><div class="line">m - Memory info (show_mem)</div>
<div class="line">t - Task list (show all tasks)</div>
<div class="line">p - CPU registers (show_regs)</div>
<div class="line">w - Blocked (uninterruptible) tasks</div>
<div class="line">l - Backtrace all CPUs</div>
<div class="line">z - Dump ftrace buffer</div>
<div class="line">c - Crash system (trigger panic for kdump)</div>
<div class="line"> </div>
<div class="line">s - Sync all filesystems</div>
<div class="line">u - Remount all filesystems read-only</div>
<div class="line">b - Reboot immediately</div>
<div class="line">o - Power off</div>
<div class="line"> </div>
<div class="line">e - SIGTERM to all processes (except init)</div>
<div class="line">i - SIGKILL to all processes (except init)</div>
<div class="line">f - OOM killer (kill memory hog)</div>
<div class="line"> </div>
<div class="line">0-9 - Set console log level</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Use REISUB sequence for safe reboot when system hangs: R(raw keyboard) E(terminate) I(kill) S(sync) U(unmount) B(reboot). Wait ~1 sec between keys.</p>
<p><b>Security Note</b>: Disable in production (<code>sysrq=0</code>) to prevent unauthorized access.</p>
<h1><a class="anchor" id="autotoc_md509"></a>
Kernel Crash Dump (kdump)</h1>
<p>Capture crash dumps for post-mortem analysis.</p>
<h2><a class="anchor" id="autotoc_md510"></a>
Setup</h2>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_CRASH_DUMP=y</div>
<div class="line">CONFIG_KEXEC=y</div>
<div class="line">CONFIG_DEBUG_INFO=y</div>
</div><!-- fragment --><p>Install tools: </p><div class="fragment"><div class="line"># Debian/Ubuntu</div>
<div class="line">apt-get install kexec-tools kdump-tools</div>
<div class="line"> </div>
<div class="line"># RHEL/CentOS</div>
<div class="line">yum install kexec-tools</div>
</div><!-- fragment --><p>Configure: </p><div class="fragment"><div class="line"># Reserve memory for crash kernel (add to kernel cmdline)</div>
<div class="line">crashkernel=256M</div>
<div class="line"> </div>
<div class="line"># Load crash kernel</div>
<div class="line">kexec -p /boot/vmlinuz --initrd=/boot/initrd.img \</div>
<div class="line">      --append=&quot;root=/dev/sda1 maxcpus=1 irqpoll reset_devices&quot;</div>
<div class="line"> </div>
<div class="line"># Enable kdump service</div>
<div class="line">systemctl enable kdump</div>
<div class="line">systemctl start kdump</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md511"></a>
Triggering Crash Dump</h2>
<div class="fragment"><div class="line"># Via SysRq</div>
<div class="line">echo c &gt; /proc/sysrq-trigger</div>
<div class="line"> </div>
<div class="line"># Via kernel panic</div>
<div class="line">echo 1 &gt; /proc/sys/kernel/panic</div>
<div class="line"># Trigger panic...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md512"></a>
Analyzing Crash Dump</h2>
<div class="fragment"><div class="line"># Dump saved to /var/crash/ or /proc/vmcore</div>
<div class="line"> </div>
<div class="line"># Analyze with crash utility</div>
<div class="line">crash /usr/lib/debug/boot/vmlinux-$(uname -r) /var/crash/vmcore</div>
<div class="line"> </div>
<div class="line"># In crash shell</div>
<div class="line">crash&gt; bt          # Backtrace</div>
<div class="line">crash&gt; log         # Kernel log</div>
<div class="line">crash&gt; ps          # Process list</div>
<div class="line">crash&gt; files       # Open files</div>
<div class="line">crash&gt; vm          # Virtual memory</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Crash kernel runs in reserved memory, avoiding corruption. Use <code>makedumpfile</code> to filter dump (exclude free pages): <code>makedumpfile -c -d 31 /proc/vmcore /var/crash/vmcore</code>.</p>
<h1><a class="anchor" id="autotoc_md513"></a>
Additional Debugging Tools</h1>
<h2><a class="anchor" id="autotoc_md514"></a>
printk Index</h2>
<p>View all printk messages in the kernel:</p>
<div class="fragment"><div class="line"># Available in newer kernels (5.10+)</div>
<div class="line">cat /sys/kernel/debug/printk/index/*</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md515"></a>
Tracepoints</h2>
<p>Static instrumentation points in kernel code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;trace/events/module.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use existing tracepoints</span></div>
<div class="line">trace_module_load(mod);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define custom tracepoint</span></div>
<div class="line">DECLARE_TRACE(my_tracepoint,</div>
<div class="line">    TP_PROTO(<span class="keywordtype">int</span> value),</div>
<div class="line">    TP_ARGS(value));</div>
</div><!-- fragment --><p>Enable tracepoints: </p><div class="fragment"><div class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/module/enable</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md516"></a>
UBSAN (Undefined Behavior Sanitizer)</h2>
<p>Detects undefined behavior at runtime.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_UBSAN=y</div>
<div class="line">CONFIG_UBSAN_TRAP=y</div>
</div><!-- fragment --><p>Detects: integer overflow, shift errors, null pointer arithmetic, etc.</p>
<h2><a class="anchor" id="autotoc_md517"></a>
KCSAN (Kernel Concurrency Sanitizer)</h2>
<p>Detects data races dynamically.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_KCSAN=y</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Uses watchpoints to detect concurrent non-atomic accesses. Reports races with stack traces of both threads.</p>
<h2><a class="anchor" id="autotoc_md518"></a>
Kernel Probes (kprobes)</h2>
<p>Dynamic instrumentation without recompilation.</p>
<div class="fragment"><div class="line"># Using perf probe</div>
<div class="line">perf probe --add=&#39;my_function arg1 arg2&#39;</div>
<div class="line">perf record -e probe:my_function -a</div>
<div class="line">perf probe --del=&#39;my_function&#39;</div>
<div class="line"> </div>
<div class="line"># Using kprobe events</div>
<div class="line">echo &#39;p:myprobe my_function arg1=%di arg2=%si&#39; &gt; /sys/kernel/debug/tracing/kprobe_events</div>
<div class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myprobe/enable</div>
<div class="line">cat /sys/kernel/debug/tracing/trace</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md519"></a>
Hardware Breakpoints</h2>
<p>Limited hardware breakpoints (typically 4 on x86).</p>
<div class="fragment"><div class="line"># Using perf</div>
<div class="line">perf record -e mem:0xffffffffa0000000:rw -a</div>
<div class="line"> </div>
<div class="line"># In KGDB</div>
<div class="line">(gdb) hbreak *0xffffffffa0000000</div>
<div class="line">(gdb) watch *(int*)0xffffffffa0000000</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md520"></a>
Kernel Oops Decoder</h2>
<div class="fragment"><div class="line"># Decode oops automatically</div>
<div class="line">./scripts/decode_stacktrace.sh vmlinux &lt; oops.txt</div>
<div class="line"> </div>
<div class="line"># With modules</div>
<div class="line">./scripts/decode_stacktrace.sh vmlinux /lib/modules/$(uname -r) &lt; oops.txt</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md521"></a>
Fault Injection</h2>
<p>Test error handling paths.</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_FAULT_INJECTION=y</div>
<div class="line">CONFIG_FAILSLAB=y</div>
<div class="line">CONFIG_FAIL_PAGE_ALLOC=y</div>
<div class="line">CONFIG_FAIL_IO_TIMEOUT=y</div>
</div><!-- fragment --><p>Usage: </p><div class="fragment"><div class="line"># Fail 10% of kmalloc calls</div>
<div class="line">echo 10 &gt; /sys/kernel/debug/failslab/probability</div>
<div class="line">echo 1 &gt; /sys/kernel/debug/failslab/times</div>
<div class="line">echo 1 &gt; /sys/kernel/debug/failslab/ignore-gfp-wait</div>
<div class="line"> </div>
<div class="line"># Trigger specific failure</div>
<div class="line">echo 1 &gt; /sys/kernel/debug/fail_page_alloc/task-filter</div>
<div class="line">bash -c &quot;echo $$ &gt; /proc/self/make-it-fail &amp;&amp; ./test_program&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md522"></a>
Kernel Address Space Layout Randomization (KASLR)</h2>
<p>Disable for debugging:</p>
<div class="fragment"><div class="line"># Boot parameter</div>
<div class="line">nokaslr</div>
<div class="line"> </div>
<div class="line"># Check if enabled</div>
<div class="line">cat /proc/sys/kernel/randomize_va_space</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md523"></a>
Live Patching Debug</h2>
<p>For live kernel patching:</p>
<div class="fragment"><div class="line"># Check patch status</div>
<div class="line">cat /sys/kernel/livepatch/*/enabled</div>
<div class="line"> </div>
<div class="line"># Enable debug</div>
<div class="line">echo &#39;module livepatch +p&#39; &gt; /sys/kernel/debug/dynamic_debug/control</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md524"></a>
perf</h2>
<p>Performance analysis and profiling.</p>
<div class="fragment"><div class="line"># Record CPU samples</div>
<div class="line">perf record -a -g  # -a: all CPUs, -g: call graph</div>
<div class="line"> </div>
<div class="line"># Record specific event</div>
<div class="line">perf record -e kmem:kmalloc -a</div>
<div class="line"> </div>
<div class="line"># View report</div>
<div class="line">perf report</div>
<div class="line"> </div>
<div class="line"># Live top</div>
<div class="line">perf top</div>
<div class="line"> </div>
<div class="line"># Trace system calls</div>
<div class="line">perf trace</div>
<div class="line"> </div>
<div class="line"># Annotate source</div>
<div class="line">perf annotate</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: Use <code>perf probe</code> to add dynamic tracepoints: &lsquo;perf probe --add='my_function var1 var2&rsquo;`. Supports hardware counters (cache misses, branch mispredictions).</p>
<h2><a class="anchor" id="autotoc_md525"></a>
strace</h2>
<p>Trace user-space system calls (useful for driver interaction).</p>
<div class="fragment"><div class="line"># Trace all syscalls</div>
<div class="line">strace ./myapp</div>
<div class="line"> </div>
<div class="line"># Filter specific calls</div>
<div class="line">strace -e open,read,write,ioctl ./myapp</div>
<div class="line"> </div>
<div class="line"># Attach to running process</div>
<div class="line">strace -p 1234</div>
<div class="line"> </div>
<div class="line"># Show timestamps</div>
<div class="line">strace -t ./myapp</div>
<div class="line"> </div>
<div class="line"># Count calls</div>
<div class="line">strace -c ./myapp</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md526"></a>
SystemTap</h2>
<p>Dynamic instrumentation framework.</p>
<div class="fragment"><div class="line"># Install</div>
<div class="line">apt-get install systemtap systemtap-runtime</div>
<div class="line"> </div>
<div class="line"># Simple script</div>
<div class="line">stap -e &#39;probe kernel.function(&quot;my_function&quot;) { println(&quot;Called!&quot;) }&#39;</div>
<div class="line"> </div>
<div class="line"># With arguments</div>
<div class="line">stap -e &#39;probe kernel.function(&quot;my_function&quot;) { </div>
<div class="line">    printf(&quot;arg1=%d\n&quot;, $arg1) </div>
<div class="line">}&#39;</div>
<div class="line"> </div>
<div class="line"># List available probes</div>
<div class="line">stap -l &#39;kernel.function(&quot;*&quot;)&#39;</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: SystemTap compiles scripts to kernel modules. More powerful than ftrace but requires kernel headers. Use for complex conditional tracing.</p>
<h2><a class="anchor" id="autotoc_md527"></a>
eBPF/bpftrace</h2>
<p>Modern tracing with BPF.</p>
<div class="fragment"><div class="line"># Install</div>
<div class="line">apt-get install bpftrace</div>
<div class="line"> </div>
<div class="line"># Trace function calls</div>
<div class="line">bpftrace -e &#39;kprobe:my_function { @[comm] = count(); }&#39;</div>
<div class="line"> </div>
<div class="line"># Trace with arguments</div>
<div class="line">bpftrace -e &#39;kprobe:my_function { printf(&quot;%d\n&quot;, arg0); }&#39;</div>
<div class="line"> </div>
<div class="line"># Histogram of latencies</div>
<div class="line">bpftrace -e &#39;kprobe:my_function { @start[tid] = nsecs; }</div>
<div class="line">             kretprobe:my_function { </div>
<div class="line">                 @latency = hist(nsecs - @start[tid]); </div>
<div class="line">                 delete(@start[tid]); </div>
<div class="line">             }&#39;</div>
</div><!-- fragment --><p><b>Deeper Insight</b>: eBPF runs in kernel VM, safer than modules. Use for production tracing with minimal overhead. Supports networking, security, and performance monitoring.</p>
<h1><a class="anchor" id="autotoc_md528"></a>
Best Practices</h1>
<ol type="1">
<li><b>Use appropriate log levels</b>: Debug for development, Info for key events, Error for failures.</li>
<li><b>Add debug messages</b> during development, but use <code>#ifdef DEBUG</code> or dynamic debug for toggling.</li>
<li><b>Remove or disable</b> verbose debug in production to avoid performance hits and log flooding.</li>
<li><b>Use debugfs</b> for runtime debugging; prefer seq_file for large outputs to avoid memory issues.</li>
<li><b>Enable kernel debugging options</b> during development (KASAN, lockdep, etc.) but disable in production.</li>
<li><b>Test with different configurations</b>: SMP for races, different architectures, various kernel versions.</li>
<li><b>Document debugging interfaces</b> in code comments and README files for maintainability.</li>
<li><b>Use version control</b> for debugging changes; git bisect for finding regressions.</li>
<li><b>Keep debug code</b> maintainable: Modular, non-intrusive, and well-commented.</li>
<li><b>Test error paths</b> thoroughly with fault injection (<code>CONFIG_FAULT_INJECTION=y</code>).</li>
<li><b>Combine tools</b>: Use ftrace with printk for timing, KASAN with lockdep for comprehensive checks.</li>
<li><b>Prioritize non-intrusive tools</b>: Start with logs/ftrace before using breakpoints (KGDB).</li>
<li><b>Rate-limit high-frequency logs</b>: Use <code>pr_info_ratelimited</code> to avoid console flooding.</li>
<li><b>Validate all inputs</b>: Check bounds, null pointers, and error returns rigorously.</li>
<li><b>Use static analysis</b>: Tools like sparse (<code>make C=1</code>) and Coccinelle catch bugs early.</li>
</ol>
<h1><a class="anchor" id="autotoc_md529"></a>
Common Issues and Solutions</h1>
<h2><a class="anchor" id="autotoc_md530"></a>
Kernel Panic</h2>
<p><b>Symptoms</b>: System halts with panic message.</p>
<p><b>Analysis</b>:</p><ul>
<li>Check dmesg/console for stack trace</li>
<li>Enable <code>CONFIG_STACKTRACE=y</code> for detailed traces</li>
<li>Use <code>addr2line</code> on vmlinux to resolve addresses</li>
<li>Check recent changes with <code>git bisect</code></li>
</ul>
<p><b>Tools</b>: KASAN for memory bugs, lockdep for deadlocks, kdump for post-mortem.</p>
<p><b>Deeper</b>: Panics from NULL derefs, BUG_ON, or hardware faults. Use KGDB to catch before panic.</p>
<h2><a class="anchor" id="autotoc_md531"></a>
Memory Corruption</h2>
<p><b>Symptoms</b>: Random crashes, data corruption, use-after-free.</p>
<p><b>Analysis</b>:</p><ul>
<li>Enable <code>CONFIG_KASAN=y</code> (address sanitizer)</li>
<li>Enable <code>CONFIG_SLUB_DEBUG=y</code> with <code>slub_debug=FZPU</code></li>
<li>Check for buffer overflows, off-by-one errors</li>
<li>Use kmemleak for memory leaks</li>
</ul>
<p><b>Tools</b>: KASAN (best), SLUB debug, kmemleak, Valgrind (user-space).</p>
<p><b>Deeper</b>: KASAN detects use-after-free, overflows. Test with <code>kmemcheck</code> for uninitialized reads (deprecated, use KMSAN).</p>
<h2><a class="anchor" id="autotoc_md532"></a>
Deadlock</h2>
<p><b>Symptoms</b>: System hangs, processes in D state (uninterruptible sleep).</p>
<p><b>Analysis</b>:</p><ul>
<li>Enable <code>CONFIG_LOCKDEP=y</code> (lock dependency checker)</li>
<li>Check lock ordering with <code>cat /proc/lockdep</code></li>
<li>Use SysRq+w to show blocked tasks</li>
<li>Review locking logic for circular dependencies</li>
</ul>
<p><b>Tools</b>: Lockdep (best), SysRq, lock_stat for contention.</p>
<p><b>Deeper</b>: Lockdep tracks lock orders; detects cycles. Visualize with <code>dot</code> graphs from /proc/lockdep_chains.</p>
<h2><a class="anchor" id="autotoc_md533"></a>
Race Conditions</h2>
<p><b>Symptoms</b>: Intermittent failures, data corruption, timing-dependent bugs.</p>
<p><b>Analysis</b>:</p><ul>
<li>Use proper synchronization (mutexes, spinlocks, RCU)</li>
<li>Enable <code>CONFIG_PROVE_LOCKING=y</code> and <code>CONFIG_DEBUG_ATOMIC_SLEEP=y</code></li>
<li>Test with multiple CPUs and stress tools</li>
<li>Use Thread Sanitizer (TSan) if available</li>
</ul>
<p><b>Tools</b>: Lockdep, stress-ng, perf for profiling.</p>
<p><b>Deeper</b>: Test with <code>stress-ng --cpu 8 --io 4 --vm 2</code>. Use <code>CONFIG_DEBUG_SPINLOCK=y</code> for spinlock checks.</p>
<h2><a class="anchor" id="autotoc_md534"></a>
Performance Issues</h2>
<p><b>Symptoms</b>: Slow operations, high CPU usage, latency spikes.</p>
<p><b>Analysis</b>:</p><ul>
<li>Profile with <code>perf record -a -g</code></li>
<li>Use ftrace function_graph for timing</li>
<li>Check lock contention with lock_stat</li>
<li>Analyze with <code>perf top</code> for hot functions</li>
</ul>
<p><b>Tools</b>: perf, ftrace, eBPF/bpftrace, lock_stat.</p>
<p><b>Deeper</b>: Use <code>perf stat</code> for hardware counters (cache misses). Optimize hot paths, reduce locking.</p>
<h2><a class="anchor" id="autotoc_md535"></a>
Hardware Issues</h2>
<p><b>Symptoms</b>: Intermittent failures, device timeouts, DMA errors.</p>
<p><b>Analysis</b>:</p><ul>
<li>Check hardware registers with debugfs</li>
<li>Use logic analyzer or oscilloscope for signals</li>
<li>Enable device-specific debug (e.g., <code>dyndbg</code> for USB)</li>
<li>Test with different hardware revisions</li>
</ul>
<p><b>Tools</b>: debugfs, ftrace for driver calls, hardware tools.</p>
<p><b>Deeper</b>: DMA issues often from wrong addresses or cache coherency. Use <code>dma_map_single</code> correctly.</p>
<p><b>Block Diagram: Common Debugging Workflow</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_21.png" alt="dot_inline_dotgraph_21.png" border="0" usemap="#dot_inline_dotgraph_21.map"/>
</div>
<h1><a class="anchor" id="autotoc_md536"></a>
Critical Missing Concepts</h1>
<h2><a class="anchor" id="autotoc_md537"></a>
1. Debugging Concurrency Issues (CRITICAL)</h2>
<p><b>Why Critical</b>: 70% of hard bugs are race conditions and concurrency issues.</p>
<p><b>Terminology</b>:</p><ul>
<li><b>Race Condition</b>: Two threads access same data simultaneously, causing bugs</li>
<li><b>Concurrency</b>: Multiple things happening at the same time</li>
<li><b>Thread</b>: Separate execution path (like a worker)</li>
<li><b>Atomic Operation</b>: Operation that completes without interruption</li>
<li><b>Spinlock</b>: Lock that "spins" (busy-waits) until available</li>
<li><b>Mutex</b>: Lock that sleeps while waiting (can't use in interrupt!)</li>
</ul>
<h3><a class="anchor" id="autotoc_md538"></a>
Understanding Race Conditions</h3>
<p><b>What is a Race Condition?</b></p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_22.png" alt="dot_inline_dotgraph_22.png" border="0" usemap="#dot_inline_dotgraph_22.map"/>
</div>
<p><b>Timeline of Race Condition</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_23.png" alt="dot_inline_dotgraph_23.png" border="0" usemap="#dot_inline_dotgraph_23.map"/>
</div>
<p><b>Solution: Using Locks</b>:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_24.png" alt="dot_inline_dotgraph_24.png" border="0" usemap="#dot_inline_dotgraph_24.map"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// BUGGY CODE - Race condition</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 1                    // Thread 2</span></div>
<div class="line">counter++;                     counter++;</div>
<div class="line"><span class="comment">// Expected: counter = 2</span></div>
<div class="line"><span class="comment">// Actual: counter = 1 (race!)</span></div>
</div><!-- fragment --><p><b>What Happens</b>: </p><div class="fragment"><div class="line">Thread 1: Read counter (0)</div>
<div class="line">Thread 2: Read counter (0)     ← Both read same value!</div>
<div class="line">Thread 1: Write counter (1)</div>
<div class="line">Thread 2: Write counter (1)    ← Lost update!</div>
</div><!-- fragment --><p><b>How to Debug</b>:</p>
<div class="fragment"><div class="line"><span class="comment">// lab8_race_condition.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kthread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/delay.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> counter_safe = 0;</div>
<div class="line"><span class="keyword">static</span> DEFINE_SPINLOCK(counter_lock);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> thread_func(<span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span> = *(<span class="keywordtype">int</span> *)data;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 10000; i++) {</div>
<div class="line">        <span class="comment">// BUGGY: No protection</span></div>
<div class="line">        counter++;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// SAFE: With lock</span></div>
<div class="line">        spin_lock(&amp;counter_lock);</div>
<div class="line">        counter_safe++;</div>
<div class="line">        spin_unlock(&amp;counter_lock);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Thread %d done\n&quot;</span>, <span class="keywordtype">id</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab8_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>task_struct *t1, *t2;</div>
<div class="line">    <span class="keywordtype">int</span> id1 = 1, id2 = 2;</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;=== Lab 8: Race Condition ===\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    t1 = kthread_run(thread_func, &amp;id1, <span class="stringliteral">&quot;race_thread1&quot;</span>);</div>
<div class="line">    t2 = kthread_run(thread_func, &amp;id2, <span class="stringliteral">&quot;race_thread2&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    msleep(2000); <span class="comment">// Wait for threads</span></div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Buggy counter: %d (expected 20000)\n&quot;</span>, counter);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Safe counter: %d (expected 20000)\n&quot;</span>, counter_safe);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(lab8_init);</div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><p><b>Tools to Detect Races</b>:</p><ul>
<li>KCSAN (Kernel Concurrency Sanitizer)</li>
<li>Lockdep (lock ordering)</li>
<li>ThreadSanitizer</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md540"></a>
2. Debugging Real Hardware Issues (CRITICAL)</h2>
<p><b>Why Critical</b>: Drivers interact with hardware - software tools can't catch all bugs.</p>
<h3><a class="anchor" id="autotoc_md541"></a>
Hardware Register Debugging</h3>
<div class="fragment"><div class="line"><span class="comment">// lab9_hardware_debug.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define REG_STATUS  0x00</span></div>
<div class="line"><span class="preprocessor">#define REG_CONTROL 0x04</span></div>
<div class="line"><span class="preprocessor">#define REG_DATA    0x08</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __iomem *base;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> dump_hardware_state(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    u32 status, control, data;</div>
<div class="line">    </div>
<div class="line">    status = ioread32(base + REG_STATUS);</div>
<div class="line">    control = ioread32(base + REG_CONTROL);</div>
<div class="line">    data = ioread32(base + REG_DATA);</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Hardware State:\n&quot;</span>);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;  STATUS:  0x%08x\n&quot;</span>, status);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;  CONTROL: 0x%08x\n&quot;</span>, control);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;  DATA:    0x%08x\n&quot;</span>, data);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Decode status bits</span></div>
<div class="line">    pr_info(<span class="stringliteral">&quot;  Status bits:\n&quot;</span>);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;    READY:   %s\n&quot;</span>, (status &amp; BIT(0)) ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no&quot;</span>);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;    ERROR:   %s\n&quot;</span>, (status &amp; BIT(1)) ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no&quot;</span>);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;    BUSY:    %s\n&quot;</span>, (status &amp; BIT(2)) ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debugfs interface to dump registers</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> regs_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    </div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Register Dump:\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 0x100; i += 4) {</div>
<div class="line">        u32 val = ioread32(base + i);</div>
<div class="line">        seq_printf(m, <span class="stringliteral">&quot;0x%02x: 0x%08x\n&quot;</span>, i, val);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Hardware Debug Checklist</b>:</p><ul>
<li>[ ] Check register values match datasheet</li>
<li>[ ] Verify timing (setup/hold times)</li>
<li>[ ] Check interrupt status registers</li>
<li>[ ] Verify DMA addresses are physical (not virtual!)</li>
<li>[ ] Check endianness (ioread32 vs readl)</li>
<li>[ ] Verify memory barriers (rmb/wmb)</li>
</ul>
<p><b>Tools</b>:</p><ul>
<li>Logic analyzer (for signals)</li>
<li>Oscilloscope (for timing)</li>
<li>Bus analyzer (I2C/SPI/PCIe)</li>
<li>debugfs register dumps</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md543"></a>
3. Debugging Module Dependencies (IMPORTANT)</h2>
<p><b>Why Important</b>: Module load failures are common and confusing.</p>
<div class="fragment"><div class="line"># Check why module won&#39;t load</div>
<div class="line">modprobe -v mymodule</div>
<div class="line"> </div>
<div class="line"># Check dependencies</div>
<div class="line">modinfo mymodule | grep depends</div>
<div class="line"> </div>
<div class="line"># Check missing symbols</div>
<div class="line">dmesg | grep &quot;Unknown symbol&quot;</div>
<div class="line"> </div>
<div class="line"># Find symbol provider</div>
<div class="line">grep -r &quot;EXPORT_SYMBOL.*my_symbol&quot; /lib/modules/$(uname -r)/</div>
<div class="line"> </div>
<div class="line"># Check symbol versions</div>
<div class="line">modprobe --dump-modversions mymodule.ko</div>
</div><!-- fragment --><p><b>Common Issues</b>: </p><div class="fragment"><div class="line"><span class="comment">// Module A exports symbol</span></div>
<div class="line">EXPORT_SYMBOL_GPL(my_function);  <span class="comment">// GPL only!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Module B tries to use it</span></div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;Proprietary&quot;</span>);   <span class="comment">// FAIL! Can&#39;t use GPL symbols</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md545"></a>
4. Debugging with /proc and /sys (IMPORTANT)</h2>
<p><b>Why Important</b>: Quick runtime inspection without debugfs.</p>
<div class="fragment"><div class="line"><span class="comment">// lab10_proc_debug.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/proc_fs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/seq_file.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> stats_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Driver Statistics:\n&quot;</span>);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Interrupts: %lu\n&quot;</span>, irq_count);</div>
<div class="line">    seq_printf(m, <span class="stringliteral">&quot;Errors: %lu\n&quot;</span>, error_count);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> stats_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> single_open(file, stats_show, NULL);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>proc_ops stats_pops = {</div>
<div class="line">    .proc_open    = stats_open,</div>
<div class="line">    .proc_read    = seq_read,</div>
<div class="line">    .proc_lseek   = seq_lseek,</div>
<div class="line">    .proc_release = single_release,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab10_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    proc_create(<span class="stringliteral">&quot;driver/mystats&quot;</span>, 0444, NULL, &amp;stats_pops);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Useful /proc entries</b>: </p><div class="fragment"><div class="line">cat /proc/interrupts        # IRQ counts</div>
<div class="line">cat /proc/iomem            # Memory regions</div>
<div class="line">cat /proc/ioports          # I/O ports</div>
<div class="line">cat /proc/modules          # Loaded modules</div>
<div class="line">cat /proc/kallsyms         # Kernel symbols</div>
<div class="line">cat /proc/slabinfo         # Memory allocations</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md547"></a>
5. Debugging Error Paths (CRITICAL)</h2>
<p><b>Why Critical</b>: Most bugs are in error handling code that rarely executes.</p>
<div class="fragment"><div class="line"><span class="comment">// COMMON BUG: Forgetting cleanup on error</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init buggy_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ptr1 = kmalloc(100, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr1)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    ptr2 = kmalloc(200, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr2)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;  <span class="comment">// BUG: ptr1 leaked!</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (register_device() &lt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> -ENODEV;  <span class="comment">// BUG: ptr1, ptr2 leaked!</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CORRECT: Proper error handling</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init correct_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    </div>
<div class="line">    ptr1 = kmalloc(100, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr1)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    ptr2 = kmalloc(200, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!ptr2) {</div>
<div class="line">        ret = -ENOMEM;</div>
<div class="line">        <span class="keywordflow">goto</span> err_free_ptr1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ret = register_device();</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0)</div>
<div class="line">        <span class="keywordflow">goto</span> err_free_ptr2;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">err_free_ptr2:</div>
<div class="line">    kfree(ptr2);</div>
<div class="line">err_free_ptr1:</div>
<div class="line">    kfree(ptr1);</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Testing Error Paths</b>: </p><div class="fragment"><div class="line"># Use fault injection</div>
<div class="line">echo 10 &gt; /sys/kernel/debug/failslab/probability  # 10% failure rate</div>
<div class="line">insmod mymodule.ko  # Test multiple times</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md549"></a>
6. Debugging Timing Issues (IMPORTANT)</h2>
<p><b>Why Important</b>: Timing bugs are intermittent and hard to reproduce.</p>
<div class="fragment"><div class="line"><span class="comment">// lab11_timing_debug.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/ktime.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> measure_function_time(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ktime_t start, end;</div>
<div class="line">    s64 delta_ns;</div>
<div class="line">    </div>
<div class="line">    start = ktime_get();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Function to measure</span></div>
<div class="line">    expensive_operation();</div>
<div class="line">    </div>
<div class="line">    end = ktime_get();</div>
<div class="line">    delta_ns = ktime_to_ns(ktime_sub(end, start));</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Operation took %lld ns (%lld us)\n&quot;</span>, </div>
<div class="line">            delta_ns, delta_ns / 1000);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Warn if too slow</span></div>
<div class="line">    <span class="keywordflow">if</span> (delta_ns &gt; 1000000) <span class="comment">// 1ms</span></div>
<div class="line">        pr_warn(<span class="stringliteral">&quot;Operation too slow!\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use ftrace for detailed timing</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> trace_timing(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    trace_printk(<span class="stringliteral">&quot;Starting operation\n&quot;</span>);</div>
<div class="line">    expensive_operation();</div>
<div class="line">    trace_printk(<span class="stringliteral">&quot;Finished operation\n&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Timing Tools</b>: </p><div class="fragment"><div class="line"># Function graph shows timing</div>
<div class="line">echo function_graph &gt; /sys/kernel/debug/tracing/current_tracer</div>
<div class="line">echo my_function &gt; /sys/kernel/debug/tracing/set_ftrace_filter</div>
<div class="line">cat /sys/kernel/debug/tracing/trace</div>
<div class="line"> </div>
<div class="line"># Output shows duration:</div>
<div class="line"># my_function() {</div>
<div class="line">#   sub_function() {  /* 123.456 us */</div>
<div class="line">#   }</div>
<div class="line"># } /* 234.567 us */</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md551"></a>
7. Debugging Kernel Threads (IMPORTANT)</h2>
<div class="fragment"><div class="line"><span class="comment">// lab12_kthread_debug.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kthread.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>task_struct *my_thread;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> thread_function(<span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Thread started, PID=%d\n&quot;</span>, current-&gt;pid);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (!kthread_should_stop()) {</div>
<div class="line">        pr_debug(<span class="stringliteral">&quot;Thread running...\n&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check if we should stop</span></div>
<div class="line">        <span class="keywordflow">if</span> (kthread_should_stop())</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">        msleep_interruptible(1000);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Thread stopping\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init lab12_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    my_thread = kthread_run(thread_function, NULL, <span class="stringliteral">&quot;my_kthread&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(my_thread)) {</div>
<div class="line">        pr_err(<span class="stringliteral">&quot;Failed to create thread\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(my_thread);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Thread created\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit lab12_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (my_thread) {</div>
<div class="line">        kthread_stop(my_thread);  <span class="comment">// Waits for thread to exit</span></div>
<div class="line">        pr_info(<span class="stringliteral">&quot;Thread stopped\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Debug Kernel Threads</b>: </p><div class="fragment"><div class="line"># List kernel threads</div>
<div class="line">ps aux | grep &quot;\[.*\]&quot;</div>
<div class="line"> </div>
<div class="line"># Check thread state</div>
<div class="line">cat /proc/&lt;PID&gt;/status</div>
<div class="line"> </div>
<div class="line"># Stack trace of thread</div>
<div class="line">cat /proc/&lt;PID&gt;/stack</div>
<div class="line"> </div>
<div class="line"># All blocked threads</div>
<div class="line">echo w &gt; /proc/sysrq-trigger</div>
<div class="line">dmesg | grep &quot;blocked for&quot;</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md553"></a>
8. Debugging with trace_printk (FAST printk)</h2>
<p><b>Why Important</b>: printk is slow, trace_printk is 10x faster for high-frequency logging.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Regular printk - SLOW (console overhead)</span></div>
<div class="line">pr_info(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// trace_printk - FAST (ring buffer only)</span></div>
<div class="line">trace_printk(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read output</span></div>
<div class="line"><span class="comment">// cat /sys/kernel/debug/tracing/trace</span></div>
</div><!-- fragment --><p><b>When to Use</b>:</p><ul>
<li>High-frequency paths (interrupt handlers)</li>
<li>Timing-sensitive code</li>
<li>Performance debugging</li>
</ul>
<p><b>Warning</b>: trace_printk is for debugging only, not production!</p>
<hr  />
<h2><a class="anchor" id="autotoc_md555"></a>
9. Debugging Reference Counting</h2>
<p><b>Why Important</b>: Reference count bugs cause use-after-free and memory leaks.</p>
<div class="fragment"><div class="line"><span class="comment">// lab13_refcount_debug.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kref.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_object {</div>
<div class="line">    <span class="keyword">struct </span>kref refcount;</div>
<div class="line">    <span class="keywordtype">int</span> data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_object_release(<span class="keyword">struct</span> kref *ref)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_object *obj = container_of(ref, <span class="keyword">struct</span> my_object, refcount);</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Object released, refcount reached 0\n&quot;</span>);</div>
<div class="line">    kfree(obj);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>my_object *my_object_get(<span class="keyword">struct</span> my_object *obj)</div>
<div class="line">{</div>
<div class="line">    kref_get(&amp;obj-&gt;refcount);</div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;get: refcount=%d\n&quot;</span>, kref_read(&amp;obj-&gt;refcount));</div>
<div class="line">    <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_object_put(<span class="keyword">struct</span> my_object *obj)</div>
<div class="line">{</div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;put: refcount=%d\n&quot;</span>, kref_read(&amp;obj-&gt;refcount));</div>
<div class="line">    kref_put(&amp;obj-&gt;refcount, my_object_release);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable CONFIG_DEBUG_KOBJECT=y to debug kobject refcounts</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md557"></a>
10. Debugging Build Issues</h2>
<div class="fragment"><div class="line"># Verbose build</div>
<div class="line">make V=1</div>
<div class="line"> </div>
<div class="line"># Check for warnings (treat as errors)</div>
<div class="line">make W=1</div>
<div class="line"> </div>
<div class="line"># Static analysis</div>
<div class="line">make C=1  # Run sparse</div>
<div class="line">make C=2  # Run sparse on all files</div>
<div class="line"> </div>
<div class="line"># Check for common bugs</div>
<div class="line">./scripts/checkpatch.pl --file mydriver.c</div>
<div class="line"> </div>
<div class="line"># Find undefined symbols</div>
<div class="line">nm mymodule.ko | grep &quot; U &quot;</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md559"></a>
Summary: Critical Missing Concepts Added</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept </th><th class="markdownTableHeadNone">Importance </th><th class="markdownTableHeadNone">Difficulty </th><th class="markdownTableHeadNone">Time to Learn  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1. Concurrency/Races </td><td class="markdownTableBodyNone">⭐⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">10-15h  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2. Hardware Debug </td><td class="markdownTableBodyNone">⭐⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">15-20h  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3. Module Dependencies </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐ </td><td class="markdownTableBodyNone">2-3h  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4. /proc and /sys </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐ </td><td class="markdownTableBodyNone">3-5h  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5. Error Path Testing </td><td class="markdownTableBodyNone">⭐⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">5-8h  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6. Timing Issues </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">5-7h  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7. Kernel Threads </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">4-6h  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8. trace_printk </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐ </td><td class="markdownTableBodyNone">1-2h  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">9. Reference Counting </td><td class="markdownTableBodyNone">⭐⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">5-8h  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10. Build Issues </td><td class="markdownTableBodyNone">⭐⭐⭐ </td><td class="markdownTableBodyNone">⭐⭐ </td><td class="markdownTableBodyNone">2-4h  </td></tr>
</table>
<p><b>Total Additional Learning</b>: 52-78 hours for complete mastery</p>
<p><b>Most Critical</b> (Must Learn):</p><ol type="1">
<li>Concurrency/Race debugging (70% of hard bugs)</li>
<li>Hardware register debugging (driver-specific)</li>
<li>Error path testing (most bugs hide here)</li>
</ol>
<h1><a class="anchor" id="autotoc_md560"></a>
Debugging Specific Scenarios</h1>
<h2><a class="anchor" id="autotoc_md561"></a>
Interrupt Context Debugging</h2>
<p>Special considerations for interrupt handlers:</p>
<div class="fragment"><div class="line"><span class="comment">// Check if in interrupt context</span></div>
<div class="line"><span class="keywordflow">if</span> (in_interrupt()) {</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;In interrupt context\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe logging in IRQ</span></div>
<div class="line">printk_deferred(KERN_INFO <span class="stringliteral">&quot;IRQ handler called\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Trace IRQ</span></div>
<div class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/irq/enable</div>
</div><!-- fragment --><p><b>Pitfall</b>: Cannot sleep in interrupt context. Use <code>in_atomic()</code> to check.</p>
<h2><a class="anchor" id="autotoc_md562"></a>
DMA Debugging</h2>
<p>Debug DMA issues:</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_DMA_API_DEBUG=y</div>
</div><!-- fragment --><div class="fragment"><div class="line"># Check DMA debug info</div>
<div class="line">cat /sys/kernel/debug/dma-api/error_count</div>
<div class="line">cat /sys/kernel/debug/dma-api/all_errors</div>
<div class="line">cat /sys/kernel/debug/dma-api/dump</div>
</div><!-- fragment --><p>Detects: double mapping, unmapping errors, leaks, wrong direction.</p>
<h2><a class="anchor" id="autotoc_md563"></a>
Device Tree Debugging</h2>
<p>Debug device tree issues:</p>
<div class="fragment"><div class="line"># View compiled device tree</div>
<div class="line">dtc -I fs /sys/firmware/devicetree/base</div>
<div class="line"> </div>
<div class="line"># Check device tree errors</div>
<div class="line">dmesg | grep -i &quot;device tree&quot;</div>
<div class="line"> </div>
<div class="line"># List OF devices</div>
<div class="line">ls /sys/firmware/devicetree/base/</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md564"></a>
Power Management Debugging</h2>
<p>Debug suspend/resume:</p>
<div class="fragment"><div class="line"># Enable PM debug</div>
<div class="line">echo 1 &gt; /sys/power/pm_debug_messages</div>
<div class="line">echo devices &gt; /sys/power/pm_test</div>
<div class="line"> </div>
<div class="line"># Trace PM events</div>
<div class="line">echo 1 &gt; /sys/kernel/debug/tracing/events/power/enable</div>
<div class="line"> </div>
<div class="line"># Check wakeup sources</div>
<div class="line">cat /sys/kernel/debug/wakeup_sources</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md565"></a>
Module Loading Issues</h2>
<p>Debug module load failures:</p>
<div class="fragment"><div class="line"># Verbose module loading</div>
<div class="line">modprobe -v mymodule</div>
<div class="line"> </div>
<div class="line"># Check module dependencies</div>
<div class="line">modinfo mymodule</div>
<div class="line"> </div>
<div class="line"># Force load (dangerous)</div>
<div class="line">insmod mymodule.ko</div>
<div class="line"> </div>
<div class="line"># Check symbol resolution</div>
<div class="line">cat /proc/kallsyms | grep my_symbol</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md566"></a>
Register Dumps</h2>
<p>Dump hardware registers:</p>
<div class="fragment"><div class="line"><span class="comment">// In driver code</span></div>
<div class="line"><span class="keywordtype">void</span> dump_registers(<span class="keywordtype">void</span> __iomem *base)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    pr_info(<span class="stringliteral">&quot;Register dump:\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 0x100; i += 4) {</div>
<div class="line">        pr_info(<span class="stringliteral">&quot;0x%02x: 0x%08x\n&quot;</span>, i, readl(base + i));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Via debugfs</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> regs_show(<span class="keyword">struct</span> seq_file *m, <span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = m-&gt;private;</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 0x100; i += 4) {</div>
<div class="line">        seq_printf(m, <span class="stringliteral">&quot;0x%02x: 0x%08x\n&quot;</span>, i, </div>
<div class="line">                   readl(dev-&gt;base + i));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md567"></a>
Timing and Latency Analysis</h2>
<p>Measure execution time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/ktime.h&gt;</span></div>
<div class="line"> </div>
<div class="line">ktime_t start, end;</div>
<div class="line">s64 delta_us;</div>
<div class="line"> </div>
<div class="line">start = ktime_get();</div>
<div class="line"><span class="comment">// Code to measure</span></div>
<div class="line">end = ktime_get();</div>
<div class="line">delta_us = ktime_to_us(ktime_sub(end, start));</div>
<div class="line">pr_info(<span class="stringliteral">&quot;Execution time: %lld us\n&quot;</span>, delta_us);</div>
</div><!-- fragment --><p>Using ftrace for latency: </p><div class="fragment"><div class="line">echo function_graph &gt; /sys/kernel/debug/tracing/current_tracer</div>
<div class="line">echo funcgraph-duration &gt; /sys/kernel/debug/tracing/trace_options</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md568"></a>
Memory Leak Detection</h2>
<p>Beyond kmemleak:</p>
<div class="fragment"><div class="line"><span class="comment">// Track allocations manually</span></div>
<div class="line"><span class="keyword">static</span> atomic_t alloc_count = ATOMIC_INIT(0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *my_alloc(<span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> *ptr = kmalloc(size, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (ptr) {</div>
<div class="line">        atomic_inc(&amp;alloc_count);</div>
<div class="line">        pr_debug(<span class="stringliteral">&quot;Alloc: %p, count=%d\n&quot;</span>, ptr, </div>
<div class="line">                 atomic_read(&amp;alloc_count));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ptr;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_free(<span class="keywordtype">void</span> *ptr)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (ptr) {</div>
<div class="line">        atomic_dec(&amp;alloc_count);</div>
<div class="line">        pr_debug(<span class="stringliteral">&quot;Free: %p, count=%d\n&quot;</span>, ptr, </div>
<div class="line">                 atomic_read(&amp;alloc_count));</div>
<div class="line">        kfree(ptr);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check on module exit</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit my_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> count = atomic_read(&amp;alloc_count);</div>
<div class="line">    <span class="keywordflow">if</span> (count != 0)</div>
<div class="line">        pr_err(<span class="stringliteral">&quot;Memory leak: %d allocations not freed\n&quot;</span>, count);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md569"></a>
Reference Counting Debug</h2>
<p>Track kobject/device references:</p>
<p>Configuration: </p><div class="fragment"><div class="line">CONFIG_DEBUG_KOBJECT=y</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Enable kobject debug</span></div>
<div class="line"><span class="preprocessor">#define DEBUG</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kobject.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual tracking</span></div>
<div class="line"><span class="keywordtype">void</span> my_get(<span class="keyword">struct</span> my_device *dev)</div>
<div class="line">{</div>
<div class="line">    kref_get(&amp;dev-&gt;kref);</div>
<div class="line">    pr_debug(<span class="stringliteral">&quot;get: refcount=%d\n&quot;</span>, </div>
<div class="line">             kref_read(&amp;dev-&gt;kref));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md570"></a>
Debugging Checklist</h2>
<p>Before submitting code:</p>
<ul>
<li>[ ] Check all return values (especially memory allocation)</li>
<li>[ ] Validate all pointers (null checks)</li>
<li>[ ] Check array bounds (no overflows)</li>
<li>[ ] Verify locking (proper order, no deadlocks)</li>
<li>[ ] Test all error paths (fault injection)</li>
<li>[ ] Check memory allocation/deallocation (no leaks)</li>
<li>[ ] Verify cleanup code (module unload, device removal)</li>
<li>[ ] Test with debug options enabled (KASAN, lockdep)</li>
<li>[ ] Run static analysis (sparse, Coccinelle)</li>
<li>[ ] Test on multiple CPUs (race conditions)</li>
<li>[ ] Test with different kernel versions</li>
<li>[ ] Document debugging interfaces</li>
<li>[ ] Add appropriate log messages</li>
<li>[ ] Review code for common pitfalls (use-after-free, etc.)</li>
<li>[ ] Test with real hardware (not just emulation)</li>
</ul>
<h1><a class="anchor" id="autotoc_md571"></a>
Kernel Configuration for Debugging</h1>
<p>Essential debug options:</p>
<div class="fragment"><div class="line"># Core debugging</div>
<div class="line">CONFIG_DEBUG_KERNEL=y</div>
<div class="line">CONFIG_DEBUG_INFO=y</div>
<div class="line">CONFIG_DEBUG_INFO_DWARF4=y</div>
<div class="line">CONFIG_FRAME_POINTER=y</div>
<div class="line">CONFIG_STACKTRACE=y</div>
<div class="line">CONFIG_KALLSYMS=y</div>
<div class="line">CONFIG_KALLSYMS_ALL=y</div>
<div class="line"> </div>
<div class="line"># Memory debugging</div>
<div class="line">CONFIG_KASAN=y</div>
<div class="line">CONFIG_KASAN_INLINE=y</div>
<div class="line">CONFIG_SLUB_DEBUG=y</div>
<div class="line">CONFIG_DEBUG_KMEMLEAK=y</div>
<div class="line">CONFIG_DEBUG_PAGEALLOC=y</div>
<div class="line">CONFIG_PAGE_POISONING=y</div>
<div class="line">CONFIG_DEBUG_OBJECTS=y</div>
<div class="line">CONFIG_DEBUG_SLAB=y</div>
<div class="line"> </div>
<div class="line"># Lock debugging</div>
<div class="line">CONFIG_PROVE_LOCKING=y</div>
<div class="line">CONFIG_DEBUG_LOCK_ALLOC=y</div>
<div class="line">CONFIG_DEBUG_ATOMIC_SLEEP=y</div>
<div class="line">CONFIG_DEBUG_SPINLOCK=y</div>
<div class="line">CONFIG_DEBUG_MUTEXES=y</div>
<div class="line">CONFIG_DEBUG_RT_MUTEXES=y</div>
<div class="line">CONFIG_LOCKDEP=y</div>
<div class="line">CONFIG_LOCK_STAT=y</div>
<div class="line"> </div>
<div class="line"># Tracing</div>
<div class="line">CONFIG_FTRACE=y</div>
<div class="line">CONFIG_FUNCTION_TRACER=y</div>
<div class="line">CONFIG_FUNCTION_GRAPH_TRACER=y</div>
<div class="line">CONFIG_STACK_TRACER=y</div>
<div class="line">CONFIG_DYNAMIC_DEBUG=y</div>
<div class="line">CONFIG_TRACEPOINTS=y</div>
<div class="line"> </div>
<div class="line"># Sanitizers</div>
<div class="line">CONFIG_UBSAN=y</div>
<div class="line">CONFIG_KCSAN=y</div>
<div class="line"> </div>
<div class="line"># Other useful options</div>
<div class="line">CONFIG_DEBUG_LIST=y</div>
<div class="line">CONFIG_DEBUG_NOTIFIERS=y</div>
<div class="line">CONFIG_DEBUG_CREDENTIALS=y</div>
<div class="line">CONFIG_DEBUG_SG=y</div>
<div class="line">CONFIG_DEBUG_KOBJECT=y</div>
<div class="line">CONFIG_FAULT_INJECTION=y</div>
<div class="line">CONFIG_FAILSLAB=y</div>
<div class="line">CONFIG_FAIL_PAGE_ALLOC=y</div>
<div class="line">CONFIG_DMA_API_DEBUG=y</div>
<div class="line">CONFIG_DEBUG_DEVRES=y</div>
<div class="line">CONFIG_DETECT_HUNG_TASK=y</div>
<div class="line">CONFIG_WQ_WATCHDOG=y</div>
<div class="line"> </div>
<div class="line"># Crash dump</div>
<div class="line">CONFIG_CRASH_DUMP=y</div>
<div class="line">CONFIG_KEXEC=y</div>
<div class="line">CONFIG_PROC_VMCORE=y</div>
<div class="line"> </div>
<div class="line"># Debugging interfaces</div>
<div class="line">CONFIG_DEBUG_FS=y</div>
<div class="line">CONFIG_KGDB=y</div>
<div class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</div>
<div class="line">CONFIG_MAGIC_SYSRQ=y</div>
</div><!-- fragment --><p><b>Note</b>: These add significant overhead (20-50%). Use in development only.</p>
<h2><a class="anchor" id="autotoc_md572"></a>
Minimal Production Debug Config</h2>
<p>For production with minimal overhead:</p>
<div class="fragment"><div class="line">CONFIG_DEBUG_KERNEL=y</div>
<div class="line">CONFIG_DEBUG_INFO=y</div>
<div class="line">CONFIG_KALLSYMS=y</div>
<div class="line">CONFIG_FTRACE=y</div>
<div class="line">CONFIG_DYNAMIC_DEBUG=y</div>
<div class="line">CONFIG_MAGIC_SYSRQ=y</div>
<div class="line">CONFIG_CRASH_DUMP=y</div>
<div class="line">CONFIG_KEXEC=y</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md573"></a>
Advanced Debugging Techniques</h1>
<h2><a class="anchor" id="autotoc_md574"></a>
Using GDB Scripts</h2>
<p>Automate GDB debugging:</p>
<div class="fragment"><div class="line"># gdb_helpers.py</div>
<div class="line">import gdb</div>
<div class="line"> </div>
<div class="line">class DumpDevice(gdb.Command):</div>
<div class="line">    def __init__(self):</div>
<div class="line">        super(DumpDevice, self).__init__(&quot;dump-device&quot;, </div>
<div class="line">                                         gdb.COMMAND_USER)</div>
<div class="line">    </div>
<div class="line">    def invoke(self, arg, from_tty):</div>
<div class="line">        dev = gdb.parse_and_eval(arg)</div>
<div class="line">        print(&quot;Device: %s&quot; % dev[&#39;name&#39;].string())</div>
<div class="line">        print(&quot;Refcount: %d&quot; % dev[&#39;kobj&#39;][&#39;kref&#39;][&#39;refcount&#39;])</div>
<div class="line"> </div>
<div class="line">DumpDevice()</div>
</div><!-- fragment --><p>Load in GDB: </p><div class="fragment"><div class="line">(gdb) source gdb_helpers.py</div>
<div class="line">(gdb) dump-device my_device</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md575"></a>
Kernel Markers</h2>
<p>Add markers for tracing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/tracepoint.h&gt;</span></div>
<div class="line"> </div>
<div class="line">DEFINE_TRACE(my_marker);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    trace_my_marker();</div>
<div class="line">    <span class="comment">// Function code</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md576"></a>
Remote Debugging Over Network</h2>
<p>Using netconsole:</p>
<div class="fragment"><div class="line"># On target</div>
<div class="line">modprobe netconsole netconsole=@192.168.1.10/eth0,6666@192.168.1.20/</div>
<div class="line"> </div>
<div class="line"># On host</div>
<div class="line">nc -u -l 6666</div>
</div><!-- fragment --><p>Using KGDB over network (kgdboe):</p>
<div class="fragment"><div class="line"># Requires CONFIG_KGDB_KDB=y</div>
<div class="line">kgdboe=@192.168.1.10/,@192.168.1.20/</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md577"></a>
Analyzing Core Dumps</h2>
<p>Extract information from vmcore:</p>
<div class="fragment"><div class="line">crash vmlinux vmcore</div>
<div class="line"> </div>
<div class="line"># In crash shell</div>
<div class="line">crash&gt; bt              # Backtrace</div>
<div class="line">crash&gt; log             # Kernel log</div>
<div class="line">crash&gt; ps              # Process list</div>
<div class="line">crash&gt; files           # Open files</div>
<div class="line">crash&gt; vm              # Virtual memory</div>
<div class="line">crash&gt; kmem -i         # Memory info</div>
<div class="line">crash&gt; dev             # Devices</div>
<div class="line">crash&gt; mod             # Modules</div>
<div class="line">crash&gt; struct task_struct &lt;addr&gt;  # Dump structure</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md578"></a>
Binary Search for Bugs (git bisect)</h2>
<p>Find regression:</p>
<div class="fragment"><div class="line">git bisect start</div>
<div class="line">git bisect bad HEAD</div>
<div class="line">git bisect good v5.10</div>
<div class="line"># Test each commit</div>
<div class="line">git bisect good/bad</div>
<div class="line">git bisect reset</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md579"></a>
Kernel Hacking Menu</h2>
<p>Enable additional runtime checks:</p>
<div class="fragment"><div class="line">CONFIG_DEBUG_KERNEL=y</div>
<div class="line">  -&gt; Kernel hacking</div>
<div class="line">    -&gt; Memory Debugging</div>
<div class="line">    -&gt; Lock Debugging</div>
<div class="line">    -&gt; Debug Oops, Lockups and Hangs</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md580"></a>
Next Steps</h1>
<p>Proceed to <a class="el" href="md_14-time-management.html">Time Management</a> to learn about timers and time management in the kernel.</p>
<hr  />
<p><b>Summary of Enhancements</b>:</p><ul>
<li>Added deeper explanations of kernel internals (printk ring buffer, debugfs backend, etc.)</li>
<li>Included 4 ASCII block diagrams for visual understanding (printk flow, dynamic debug, debugfs, ftrace, debugging workflow)</li>
<li>Expanded ftrace section with function graph tracer and trace-cmd</li>
<li>Added KGDB section with QEMU testing tips</li>
<li>Enhanced memory debugging with KASAN, SLUB, kmemleak details</li>
<li>Added lock debugging with lockdep and lock_stat</li>
<li>Included additional tools: perf, strace, SystemTap, eBPF/bpftrace</li>
<li>Expanded best practices with 15 detailed points</li>
<li>Enhanced common issues section with deeper analysis and solutions</li>
<li>Added debugging checklist and kernel configuration section</li>
<li>Included performance considerations and pitfalls throughout</li>
<li>Added Doxygen integration notes for diagrams</li>
</ul>
<p>This enhanced version provides ~60% more content with production-ready insights for kernel driver developers. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 13 2026 16:02:34 for Linux Driver Development Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
