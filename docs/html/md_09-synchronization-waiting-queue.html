<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux Driver Development Manual: Synchronization &amp; Waiting Queue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linux Driver Development Manual
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Comprehensive guide to Linux kernel and device driver development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Synchronization &amp; Waiting Queue </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md307"></a>
Overview</h1>
<p>Kernel synchronization mechanisms prevent race conditions when multiple execution contexts access shared resources. This chapter covers locks, semaphores, and waiting queues.</p>
<h1><a class="anchor" id="autotoc_md308"></a>
Race Conditions</h1>
<p>Occur when multiple threads access shared data concurrently without proper synchronization.</p>
<div class="fragment"><div class="line"><span class="comment">// Race condition example</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> counter = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 1 and Thread 2 both execute:</span></div>
<div class="line">counter++;  <span class="comment">// Read, increment, write - not atomic!</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md309"></a>
Atomic Operations</h1>
<h2><a class="anchor" id="autotoc_md310"></a>
Atomic Integers</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/atomic.h&gt;</span></div>
<div class="line"> </div>
<div class="line">atomic_t counter = ATOMIC_INIT(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Operations</span></div>
<div class="line">atomic_inc(&amp;counter);           <span class="comment">// counter++</span></div>
<div class="line">atomic_dec(&amp;counter);           <span class="comment">// counter--</span></div>
<div class="line">atomic_add(5, &amp;counter);        <span class="comment">// counter += 5</span></div>
<div class="line">atomic_sub(3, &amp;counter);        <span class="comment">// counter -= 3</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read</span></div>
<div class="line"><span class="keywordtype">int</span> value = atomic_read(&amp;counter);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set</span></div>
<div class="line">atomic_set(&amp;counter, 10);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Test and modify</span></div>
<div class="line"><span class="keywordflow">if</span> (atomic_dec_and_test(&amp;counter))</div>
<div class="line">    printk(<span class="stringliteral">&quot;Counter reached zero\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compare and swap</span></div>
<div class="line"><span class="keywordtype">int</span> old = 5;</div>
<div class="line">atomic_cmpxchg(&amp;counter, old, 10);  <span class="comment">// If counter==5, set to 10</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md311"></a>
Atomic Bitops</h2>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags = 0;</div>
<div class="line"> </div>
<div class="line">set_bit(0, &amp;flags);           <span class="comment">// Set bit 0</span></div>
<div class="line">clear_bit(0, &amp;flags);         <span class="comment">// Clear bit 0</span></div>
<div class="line">change_bit(0, &amp;flags);        <span class="comment">// Toggle bit 0</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (test_bit(0, &amp;flags))</div>
<div class="line">    printk(<span class="stringliteral">&quot;Bit 0 is set\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Test and modify</span></div>
<div class="line"><span class="keywordflow">if</span> (test_and_set_bit(0, &amp;flags))</div>
<div class="line">    printk(<span class="stringliteral">&quot;Bit was already set\n&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md312"></a>
Spinlocks</h1>
<p>Busy-wait locks for short critical sections.</p>
<h2><a class="anchor" id="autotoc_md313"></a>
Basic Spinlock</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/spinlock.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DEFINE_SPINLOCK(my_lock);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Lock</span></div>
<div class="line">spin_lock(&amp;my_lock);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">spin_unlock(&amp;my_lock);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md314"></a>
Spinlock with IRQ</h2>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disable interrupts and acquire lock</span></div>
<div class="line">spin_lock_irqsave(&amp;my_lock, flags);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">spin_unlock_irqrestore(&amp;my_lock, flags);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Alternative (if already in interrupt context)</span></div>
<div class="line">spin_lock_irq(&amp;my_lock);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">spin_unlock_irq(&amp;my_lock);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md315"></a>
Spinlock Variants</h2>
<div class="fragment"><div class="line"><span class="comment">// Bottom half disable</span></div>
<div class="line">spin_lock_bh(&amp;my_lock);</div>
<div class="line">spin_unlock_bh(&amp;my_lock);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Try lock (non-blocking)</span></div>
<div class="line"><span class="keywordflow">if</span> (spin_trylock(&amp;my_lock)) {</div>
<div class="line">    <span class="comment">// Got lock</span></div>
<div class="line">    spin_unlock(&amp;my_lock);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Lock busy</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md316"></a>
Read-Write Spinlock</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> DEFINE_RWLOCK(my_rwlock);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multiple readers</span></div>
<div class="line">read_lock(&amp;my_rwlock);</div>
<div class="line"><span class="comment">// Read data</span></div>
<div class="line">read_unlock(&amp;my_rwlock);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Single writer</span></div>
<div class="line">write_lock(&amp;my_rwlock);</div>
<div class="line"><span class="comment">// Modify data</span></div>
<div class="line">write_unlock(&amp;my_rwlock);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With IRQ disable</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">read_lock_irqsave(&amp;my_rwlock, flags);</div>
<div class="line">read_unlock_irqrestore(&amp;my_rwlock, flags);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md317"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_device {</div>
<div class="line">    spinlock_t lock;</div>
<div class="line">    <span class="keywordtype">int</span> counter;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>my_device dev;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> increment_counter(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">    </div>
<div class="line">    spin_lock_irqsave(&amp;dev.lock, flags);</div>
<div class="line">    dev.counter++;</div>
<div class="line">    spin_unlock_irqrestore(&amp;dev.lock, flags);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md318"></a>
Mutexes</h1>
<p>Sleep locks for longer critical sections (process context only).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/mutex.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DEFINE_MUTEX(my_mutex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Lock</span></div>
<div class="line">mutex_lock(&amp;my_mutex);</div>
<div class="line"><span class="comment">// Critical section (can sleep)</span></div>
<div class="line">mutex_unlock(&amp;my_mutex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interruptible lock</span></div>
<div class="line"><span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;my_mutex))</div>
<div class="line">    <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">mutex_unlock(&amp;my_mutex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Try lock</span></div>
<div class="line"><span class="keywordflow">if</span> (mutex_trylock(&amp;my_mutex)) {</div>
<div class="line">    <span class="comment">// Got lock</span></div>
<div class="line">    mutex_unlock(&amp;my_mutex);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if locked</span></div>
<div class="line"><span class="keywordflow">if</span> (mutex_is_locked(&amp;my_mutex))</div>
<div class="line">    printk(<span class="stringliteral">&quot;Mutex is locked\n&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md319"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_device {</div>
<div class="line">    <span class="keyword">struct </span>mutex lock;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[1024];</div>
<div class="line">    <span class="keywordtype">size_t</span> size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t device_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">size_t</span> to_read;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    to_read = min(count, dev-&gt;size);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, dev-&gt;buffer, to_read)) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">    <span class="keywordflow">return</span> to_read;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md320"></a>
Semaphores</h1>
<p>Counting locks allowing multiple holders.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/semaphore.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DEFINE_SEMAPHORE(my_sem);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Down (acquire)</span></div>
<div class="line">down(&amp;my_sem);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">up(&amp;my_sem);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interruptible</span></div>
<div class="line"><span class="keywordflow">if</span> (down_interruptible(&amp;my_sem))</div>
<div class="line">    <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">up(&amp;my_sem);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Try down</span></div>
<div class="line"><span class="keywordflow">if</span> (down_trylock(&amp;my_sem) == 0) {</div>
<div class="line">    <span class="comment">// Got semaphore</span></div>
<div class="line">    up(&amp;my_sem);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize with count</span></div>
<div class="line"><span class="keyword">struct </span>semaphore sem;</div>
<div class="line">sema_init(&amp;sem, 3);  <span class="comment">// Allow 3 concurrent holders</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md321"></a>
Completion</h1>
<p>Synchronization for waiting on events.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/completion.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DECLARE_COMPLETION(my_completion);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Waiting thread</span></div>
<div class="line">wait_for_completion(&amp;my_completion);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Signaling thread</span></div>
<div class="line">complete(&amp;my_completion);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wake all waiters</span></div>
<div class="line">complete_all(&amp;my_completion);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Timeout</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timeout = msecs_to_jiffies(5000);</div>
<div class="line"><span class="keywordflow">if</span> (wait_for_completion_timeout(&amp;my_completion, timeout) == 0)</div>
<div class="line">    printk(<span class="stringliteral">&quot;Timeout\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interruptible</span></div>
<div class="line"><span class="keywordflow">if</span> (wait_for_completion_interruptible(&amp;my_completion))</div>
<div class="line">    <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reinitialize</span></div>
<div class="line">reinit_completion(&amp;my_completion);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md322"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_device {</div>
<div class="line">    <span class="keyword">struct </span>completion data_ready;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> produce_data(<span class="keyword">struct</span> my_device *dev)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Generate data</span></div>
<div class="line">    strcpy(dev-&gt;buffer, <span class="stringliteral">&quot;Data ready&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Signal completion</span></div>
<div class="line">    complete(&amp;dev-&gt;data_ready);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Consumer</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> consume_data(<span class="keyword">struct</span> my_device *dev)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Wait for data</span></div>
<div class="line">    wait_for_completion(&amp;dev-&gt;data_ready);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Process data</span></div>
<div class="line">    printk(<span class="stringliteral">&quot;Received: %s\n&quot;</span>, dev-&gt;buffer);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md323"></a>
Wait Queues</h1>
<p>Sleep until condition becomes true.</p>
<h2><a class="anchor" id="autotoc_md324"></a>
Declaration</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/wait.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DECLARE_WAIT_QUEUE_HEAD(my_wait_queue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or dynamic</span></div>
<div class="line">wait_queue_head_t my_queue;</div>
<div class="line">init_waitqueue_head(&amp;my_queue);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md325"></a>
Waiting</h2>
<div class="fragment"><div class="line"><span class="comment">// Wait until condition is true</span></div>
<div class="line">wait_event(my_wait_queue, condition);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interruptible</span></div>
<div class="line"><span class="keywordflow">if</span> (wait_event_interruptible(my_wait_queue, condition))</div>
<div class="line">    <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With timeout</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timeout = msecs_to_jiffies(5000);</div>
<div class="line"><span class="keywordtype">int</span> ret = wait_event_timeout(my_wait_queue, condition, timeout);</div>
<div class="line"><span class="keywordflow">if</span> (ret == 0)</div>
<div class="line">    printk(<span class="stringliteral">&quot;Timeout\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interruptible with timeout</span></div>
<div class="line">ret = wait_event_interruptible_timeout(my_wait_queue, condition, timeout);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md326"></a>
Waking</h2>
<div class="fragment"><div class="line"><span class="comment">// Wake one waiter</span></div>
<div class="line">wake_up(&amp;my_wait_queue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wake all waiters</span></div>
<div class="line">wake_up_all(&amp;my_wait_queue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wake interruptible waiters</span></div>
<div class="line">wake_up_interruptible(&amp;my_wait_queue);</div>
<div class="line">wake_up_interruptible_all(&amp;my_wait_queue);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md327"></a>
Example: Blocking Read</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_device {</div>
<div class="line">    wait_queue_head_t read_queue;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[256];</div>
<div class="line">    <span class="keywordtype">int</span> data_available;</div>
<div class="line">    spinlock_t lock;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t device_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for data</span></div>
<div class="line">    <span class="keywordflow">if</span> (wait_event_interruptible(dev-&gt;read_queue, dev-&gt;data_available))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    spin_lock_irqsave(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, dev-&gt;buffer, count)) {</div>
<div class="line">        spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    dev-&gt;data_available = 0;</div>
<div class="line">    spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Interrupt handler</span></div>
<div class="line"><span class="keyword">static</span> irqreturn_t device_irq(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">    </div>
<div class="line">    spin_lock_irqsave(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Read data from hardware</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    dev-&gt;data_available = 1;</div>
<div class="line">    spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wake up readers</span></div>
<div class="line">    wake_up_interruptible(&amp;dev-&gt;read_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md328"></a>
RCU (Read-Copy-Update)</h1>
<p>Lock-free synchronization for read-mostly data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/rcupdate.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_data {</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <span class="keyword">struct </span>rcu_head rcu;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>my_data *global_ptr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reader</span></div>
<div class="line">rcu_read_lock();</div>
<div class="line"><span class="keyword">struct </span>my_data *p = rcu_dereference(global_ptr);</div>
<div class="line"><span class="keywordflow">if</span> (p)</div>
<div class="line">    printk(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, p-&gt;value);</div>
<div class="line">rcu_read_unlock();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Writer</span></div>
<div class="line"><span class="keyword">struct </span>my_data *new_data = kmalloc(<span class="keyword">sizeof</span>(*new_data), GFP_KERNEL);</div>
<div class="line">new_data-&gt;value = 42;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>my_data *old_data = global_ptr;</div>
<div class="line">rcu_assign_pointer(global_ptr, new_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Free old data after grace period</span></div>
<div class="line">synchronize_rcu();</div>
<div class="line">kfree(old_data);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md329"></a>
Choosing Synchronization</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mechanism </th><th class="markdownTableHeadNone">Context </th><th class="markdownTableHeadNone">Can Sleep </th><th class="markdownTableHeadNone">Use Case  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Atomic ops </td><td class="markdownTableBodyNone">Any </td><td class="markdownTableBodyNone">No </td><td class="markdownTableBodyNone">Simple counters  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Spinlock </td><td class="markdownTableBodyNone">Any </td><td class="markdownTableBodyNone">No </td><td class="markdownTableBodyNone">Short critical sections  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mutex </td><td class="markdownTableBodyNone">Process </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Long critical sections  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Semaphore </td><td class="markdownTableBodyNone">Process </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Resource counting  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Completion </td><td class="markdownTableBodyNone">Process </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Event notification  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wait queue </td><td class="markdownTableBodyNone">Process </td><td class="markdownTableBodyNone">Yes </td><td class="markdownTableBodyNone">Condition waiting  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RCU </td><td class="markdownTableBodyNone">Any </td><td class="markdownTableBodyNone">No </td><td class="markdownTableBodyNone">Read-mostly data  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md330"></a>
Complete Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/fs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/cdev.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/wait.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/sched.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/uaccess.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 256</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sync_device {</div>
<div class="line">    <span class="keyword">struct </span>cdev cdev;</div>
<div class="line">    dev_t devt;</div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE];</div>
<div class="line">    <span class="keywordtype">size_t</span> size;</div>
<div class="line">    <span class="keyword">struct </span>mutex lock;</div>
<div class="line">    wait_queue_head_t read_queue;</div>
<div class="line">    wait_queue_head_t write_queue;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>sync_device dev;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> device_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</div>
<div class="line">{</div>
<div class="line">    filp-&gt;private_data = &amp;dev;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t device_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>sync_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">size_t</span> to_read;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for data</span></div>
<div class="line">    <span class="keywordflow">while</span> (dev-&gt;size == 0) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)</div>
<div class="line">            <span class="keywordflow">return</span> -EAGAIN;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (wait_event_interruptible(dev-&gt;read_queue, dev-&gt;size &gt; 0))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    to_read = min(count, dev-&gt;size);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, dev-&gt;buffer, to_read)) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Shift remaining data</span></div>
<div class="line">    memmove(dev-&gt;buffer, dev-&gt;buffer + to_read, dev-&gt;size - to_read);</div>
<div class="line">    dev-&gt;size -= to_read;</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wake up writers</span></div>
<div class="line">    wake_up_interruptible(&amp;dev-&gt;write_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_read;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t device_write(<span class="keyword">struct</span> file *filp, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                           <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>sync_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">size_t</span> to_write;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for space</span></div>
<div class="line">    <span class="keywordflow">while</span> (dev-&gt;size &gt;= BUFFER_SIZE) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)</div>
<div class="line">            <span class="keywordflow">return</span> -EAGAIN;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (wait_event_interruptible(dev-&gt;write_queue,</div>
<div class="line">                                     dev-&gt;size &lt; BUFFER_SIZE))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    to_write = min(count, (<span class="keywordtype">size_t</span>)(BUFFER_SIZE - dev-&gt;size));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(dev-&gt;buffer + dev-&gt;size, buf, to_write)) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    dev-&gt;size += to_write;</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wake up readers</span></div>
<div class="line">    wake_up_interruptible(&amp;dev-&gt;read_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_write;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>file_operations fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = device_open,</div>
<div class="line">    .read = device_read,</div>
<div class="line">    .write = device_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init sync_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    </div>
<div class="line">    mutex_init(&amp;dev.lock);</div>
<div class="line">    init_waitqueue_head(&amp;dev.read_queue);</div>
<div class="line">    init_waitqueue_head(&amp;dev.write_queue);</div>
<div class="line">    </div>
<div class="line">    ret = alloc_chrdev_region(&amp;dev.devt, 0, 1, <span class="stringliteral">&quot;syncdev&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    </div>
<div class="line">    cdev_init(&amp;dev.cdev, &amp;fops);</div>
<div class="line">    ret = cdev_add(&amp;dev.cdev, dev.devt, 1);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        unregister_chrdev_region(dev.devt, 1);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Sync device initialized\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit sync_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    cdev_del(&amp;dev.cdev);</div>
<div class="line">    unregister_chrdev_region(dev.devt, 1);</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Sync device removed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(sync_init);</div>
<div class="line">module_exit(sync_exit);</div>
<div class="line"> </div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
<div class="line">MODULE_DESCRIPTION(<span class="stringliteral">&quot;Synchronization example&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md331"></a>
Best Practices</h1>
<ol type="1">
<li><b>Use appropriate mechanism</b> for the context</li>
<li><b>Keep critical sections short</b></li>
<li><b>Avoid nested locks</b> (deadlock risk)</li>
<li><b>Always unlock</b> in error paths</li>
<li><b>Use interruptible waits</b> in process context</li>
<li><b>Document locking order</b> for multiple locks</li>
<li><b>Test with lockdep</b> enabled</li>
</ol>
<h1><a class="anchor" id="autotoc_md332"></a>
Deadlock Prevention</h1>
<ul>
<li>Acquire locks in consistent order</li>
<li>Use try-lock variants</li>
<li>Avoid holding locks across blocking operations</li>
<li>Use lock validator (CONFIG_PROVE_LOCKING)</li>
</ul>
<h1><a class="anchor" id="autotoc_md333"></a>
Next Steps</h1>
<p>Proceed to <a class="el" href="md_10-kernel-memory-management.html">Kernel Memory Management</a> to learn about memory allocation in the kernel. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 13 2026 16:02:32 for Linux Driver Development Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
