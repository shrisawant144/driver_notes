<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux Driver Development Manual: Interrupt Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linux Driver Development Manual
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Comprehensive guide to Linux kernel and device driver development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interrupt Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md279"></a>
Overview</h1>
<p>Interrupts are signals from hardware devices that require immediate attention from the CPU. Interrupt handlers are kernel functions that respond to these signals. This chapter covers interrupt handling in Linux device drivers.</p>
<h1><a class="anchor" id="autotoc_md280"></a>
Interrupt Basics</h1>
<h2><a class="anchor" id="autotoc_md281"></a>
Types of Interrupts</h2>
<p><b>Hardware Interrupts:</b></p><ul>
<li>Generated by hardware devices</li>
<li>Asynchronous to CPU execution</li>
<li>Examples: keyboard, network card, timer</li>
</ul>
<p><b>Software Interrupts:</b></p><ul>
<li>Generated by software (system calls, exceptions)</li>
<li>Synchronous to CPU execution</li>
</ul>
<h2><a class="anchor" id="autotoc_md282"></a>
Interrupt Flow</h2>
<div class="fragment"><div class="line">1. Device generates interrupt signal</div>
<div class="line">2. CPU stops current execution</div>
<div class="line">3. Saves context</div>
<div class="line">4. Jumps to interrupt handler</div>
<div class="line">5. Handler processes interrupt</div>
<div class="line">6. Restores context</div>
<div class="line">7. Resumes execution</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md283"></a>
Requesting Interrupts</h1>
<h2><a class="anchor" id="autotoc_md284"></a>
request_irq Function</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/interrupt.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> request_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq,</div>
<div class="line">                irq_handler_t handler,</div>
<div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *name,</div>
<div class="line">                <span class="keywordtype">void</span> *dev_id);</div>
</div><!-- fragment --><p>Parameters:</p><ul>
<li><code>irq</code>: Interrupt number</li>
<li><code>handler</code>: Interrupt handler function</li>
<li><code>flags</code>: Interrupt flags</li>
<li><code>name</code>: Device name (shown in /proc/interrupts)</li>
<li><code>dev_id</code>: Device identifier (for shared interrupts)</li>
</ul>
<h2><a class="anchor" id="autotoc_md285"></a>
Interrupt Flags</h2>
<div class="fragment"><div class="line">IRQF_SHARED        <span class="comment">// Shared interrupt line</span></div>
<div class="line">IRQF_TRIGGER_RISING    <span class="comment">// Rising edge triggered</span></div>
<div class="line">IRQF_TRIGGER_FALLING   <span class="comment">// Falling edge triggered</span></div>
<div class="line">IRQF_TRIGGER_HIGH      <span class="comment">// High level triggered</span></div>
<div class="line">IRQF_TRIGGER_LOW       <span class="comment">// Low level triggered</span></div>
<div class="line">IRQF_ONESHOT       <span class="comment">// Handler runs with interrupts disabled</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md286"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> irqreturn_t my_interrupt_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle interrupt</span></div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Interrupt received: IRQ %d\n&quot;</span>, irq);</div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init my_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    <span class="keywordtype">int</span> irq = 42;</div>
<div class="line">    </div>
<div class="line">    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED,</div>
<div class="line">                     <span class="stringliteral">&quot;mydevice&quot;</span>, &amp;my_device);</div>
<div class="line">    <span class="keywordflow">if</span> (ret) {</div>
<div class="line">        printk(KERN_ERR <span class="stringliteral">&quot;Failed to request IRQ %d: %d\n&quot;</span>, irq, ret);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;IRQ %d registered\n&quot;</span>, irq);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md287"></a>
Freeing Interrupts</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> free_irq(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit my_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    free_irq(irq, &amp;my_device);</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;IRQ freed\n&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md288"></a>
Interrupt Handler</h1>
<h2><a class="anchor" id="autotoc_md289"></a>
Handler Signature</h2>
<div class="fragment"><div class="line">irqreturn_t handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id);</div>
</div><!-- fragment --><p>Return values:</p><ul>
<li><code>IRQ_HANDLED</code>: Interrupt was handled</li>
<li><code>IRQ_NONE</code>: Interrupt not from this device</li>
<li><code>IRQ_WAKE_THREAD</code>: Wake threaded handler</li>
</ul>
<h2><a class="anchor" id="autotoc_md290"></a>
Handler Constraints</h2>
<p><b>Cannot:</b></p><ul>
<li>Sleep or block</li>
<li>Call functions that might sleep</li>
<li>Transfer data to/from user space</li>
<li>Use mutexes</li>
<li>Allocate memory with GFP_KERNEL</li>
</ul>
<p><b>Can:</b></p><ul>
<li>Use spinlocks</li>
<li>Allocate memory with GFP_ATOMIC</li>
<li>Access hardware registers</li>
<li>Schedule tasklets or work queues</li>
</ul>
<h2><a class="anchor" id="autotoc_md291"></a>
Example Handler</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> irqreturn_t my_irq_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    u32 status;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Read interrupt status</span></div>
<div class="line">    status = ioread32(dev-&gt;base + STATUS_REG);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check if interrupt is from our device</span></div>
<div class="line">    <span class="keywordflow">if</span> (!(status &amp; IRQ_FLAG))</div>
<div class="line">        <span class="keywordflow">return</span> IRQ_NONE;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Clear interrupt</span></div>
<div class="line">    iowrite32(IRQ_FLAG, dev-&gt;base + STATUS_REG);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Process interrupt</span></div>
<div class="line">    <span class="keywordflow">if</span> (status &amp; RX_READY) {</div>
<div class="line">        <span class="comment">// Handle received data</span></div>
<div class="line">        dev-&gt;rx_count++;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (status &amp; TX_COMPLETE) {</div>
<div class="line">        <span class="comment">// Handle transmission complete</span></div>
<div class="line">        dev-&gt;tx_count++;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wake up waiting processes</span></div>
<div class="line">    wake_up_interruptible(&amp;dev-&gt;wait_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md292"></a>
Shared Interrupts</h1>
<p>Multiple devices sharing the same interrupt line.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> irqreturn_t shared_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    u32 status;</div>
<div class="line">    </div>
<div class="line">    status = ioread32(dev-&gt;base + STATUS_REG);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check if interrupt is from our device</span></div>
<div class="line">    <span class="keywordflow">if</span> (!(status &amp; MY_IRQ_BIT))</div>
<div class="line">        <span class="keywordflow">return</span> IRQ_NONE;  <span class="comment">// Not our interrupt</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Handle interrupt</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Request shared interrupt</span></div>
<div class="line">ret = request_irq(irq, shared_handler, IRQF_SHARED, <span class="stringliteral">&quot;mydev&quot;</span>, dev);</div>
</div><!-- fragment --><p><b>Requirements for shared interrupts:</b></p><ul>
<li>Must provide unique <code>dev_id</code></li>
<li>Must check if interrupt is from device</li>
<li>Return <code>IRQ_NONE</code> if not from device</li>
</ul>
<h1><a class="anchor" id="autotoc_md293"></a>
Threaded Interrupts</h1>
<p>For handlers that need to perform lengthy operations.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> irqreturn_t my_hard_irq(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Quick hardware acknowledgment</span></div>
<div class="line">    iowrite32(IRQ_ACK, dev-&gt;base + STATUS_REG);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Request thread handler</span></div>
<div class="line">    <span class="keywordflow">return</span> IRQ_WAKE_THREAD;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> irqreturn_t my_thread_fn(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Lengthy processing (can sleep)</span></div>
<div class="line">    process_data(dev);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Request threaded interrupt</span></div>
<div class="line">ret = request_threaded_irq(irq, my_hard_irq, my_thread_fn,</div>
<div class="line">                          IRQF_ONESHOT, <span class="stringliteral">&quot;mydev&quot;</span>, dev);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md294"></a>
Deferred Work</h1>
<h2><a class="anchor" id="autotoc_md295"></a>
Tasklets</h2>
<p>Lightweight deferred execution in interrupt context.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/interrupt.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_tasklet_func(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = (<span class="keyword">struct </span>my_device *)data;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Process deferred work</span></div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Tasklet executed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_func, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)&amp;my_device);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In interrupt handler</span></div>
<div class="line"><span class="keyword">static</span> irqreturn_t my_irq_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Quick processing</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Schedule tasklet</span></div>
<div class="line">    tasklet_schedule(&amp;my_tasklet);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cleanup</span></div>
<div class="line">tasklet_kill(&amp;my_tasklet);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md296"></a>
Work Queues</h2>
<p>Deferred execution in process context (can sleep).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/workqueue.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_work_func(<span class="keyword">struct</span> work_struct *work)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = container_of(work, <span class="keyword">struct</span> my_device, work);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Can sleep, allocate memory, etc.</span></div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Work executed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In device structure</span></div>
<div class="line"><span class="keyword">struct </span>my_device {</div>
<div class="line">    <span class="keyword">struct </span>work_struct work;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize</span></div>
<div class="line">INIT_WORK(&amp;dev-&gt;work, my_work_func);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In interrupt handler</span></div>
<div class="line"><span class="keyword">static</span> irqreturn_t my_irq_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>my_device *dev = dev_id;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Quick processing</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Schedule work</span></div>
<div class="line">    schedule_work(&amp;dev-&gt;work);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cleanup</span></div>
<div class="line">cancel_work_sync(&amp;dev-&gt;work);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md297"></a>
Complete Interrupt Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/interrupt.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/platform_device.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/io.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/fs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/cdev.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/wait.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define DEVICE_NAME &quot;irqdev&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>irq_device {</div>
<div class="line">    <span class="keywordtype">void</span> __iomem *base;</div>
<div class="line">    <span class="keywordtype">int</span> irq;</div>
<div class="line">    <span class="keyword">struct </span>cdev cdev;</div>
<div class="line">    dev_t devt;</div>
<div class="line">    wait_queue_head_t wait_queue;</div>
<div class="line">    <span class="keywordtype">int</span> data_ready;</div>
<div class="line">    u32 data;</div>
<div class="line">    spinlock_t lock;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> irqreturn_t irq_handler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>irq_device *dev = dev_id;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">    u32 status;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Read status register</span></div>
<div class="line">    status = ioread32(dev-&gt;base);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check if our interrupt</span></div>
<div class="line">    <span class="keywordflow">if</span> (!(status &amp; 0x1))</div>
<div class="line">        <span class="keywordflow">return</span> IRQ_NONE;</div>
<div class="line">    </div>
<div class="line">    spin_lock_irqsave(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Read data</span></div>
<div class="line">    dev-&gt;data = ioread32(dev-&gt;base + 4);</div>
<div class="line">    dev-&gt;data_ready = 1;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Clear interrupt</span></div>
<div class="line">    iowrite32(0x1, dev-&gt;base);</div>
<div class="line">    </div>
<div class="line">    spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wake up waiting processes</span></div>
<div class="line">    wake_up_interruptible(&amp;dev-&gt;wait_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> IRQ_HANDLED;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> irqdev_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>irq_device *dev;</div>
<div class="line">    dev = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> irq_device, cdev);</div>
<div class="line">    filp-&gt;private_data = dev;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t irqdev_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>irq_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">    u32 data;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for data</span></div>
<div class="line">    <span class="keywordflow">if</span> (wait_event_interruptible(dev-&gt;wait_queue, dev-&gt;data_ready))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    spin_lock_irqsave(&amp;dev-&gt;lock, flags);</div>
<div class="line">    data = dev-&gt;data;</div>
<div class="line">    dev-&gt;data_ready = 0;</div>
<div class="line">    spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, &amp;data, <span class="keyword">sizeof</span>(data)))</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>file_operations irqdev_fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = irqdev_open,</div>
<div class="line">    .read = irqdev_read,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> irqdev_probe(<span class="keyword">struct</span> platform_device *pdev)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>irq_device *dev;</div>
<div class="line">    <span class="keyword">struct </span>resource *res;</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    </div>
<div class="line">    dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!dev)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get resources</span></div>
<div class="line">    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</div>
<div class="line">    dev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(dev-&gt;base))</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(dev-&gt;base);</div>
<div class="line">    </div>
<div class="line">    dev-&gt;irq = platform_get_irq(pdev, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (dev-&gt;irq &lt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> dev-&gt;irq;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize</span></div>
<div class="line">    spin_lock_init(&amp;dev-&gt;lock);</div>
<div class="line">    init_waitqueue_head(&amp;dev-&gt;wait_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Request interrupt</span></div>
<div class="line">    ret = devm_request_irq(&amp;pdev-&gt;dev, dev-&gt;irq, irq_handler,</div>
<div class="line">                          IRQF_SHARED, DEVICE_NAME, dev);</div>
<div class="line">    <span class="keywordflow">if</span> (ret) {</div>
<div class="line">        dev_err(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Failed to request IRQ\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Register character device</span></div>
<div class="line">    ret = alloc_chrdev_region(&amp;dev-&gt;devt, 0, 1, DEVICE_NAME);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0)</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    </div>
<div class="line">    cdev_init(&amp;dev-&gt;cdev, &amp;irqdev_fops);</div>
<div class="line">    ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;devt, 1);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        unregister_chrdev_region(dev-&gt;devt, 1);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    platform_set_drvdata(pdev, dev);</div>
<div class="line">    </div>
<div class="line">    dev_info(&amp;pdev-&gt;dev, <span class="stringliteral">&quot;Device initialized, IRQ %d\n&quot;</span>, dev-&gt;irq);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> irqdev_remove(<span class="keyword">struct</span> platform_device *pdev)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>irq_device *dev = platform_get_drvdata(pdev);</div>
<div class="line">    </div>
<div class="line">    cdev_del(&amp;dev-&gt;cdev);</div>
<div class="line">    unregister_chrdev_region(dev-&gt;devt, 1);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>platform_driver irqdev_driver = {</div>
<div class="line">    .probe = irqdev_probe,</div>
<div class="line">    .remove = irqdev_remove,</div>
<div class="line">    .driver = {</div>
<div class="line">        .name = DEVICE_NAME,</div>
<div class="line">    },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">module_platform_driver(irqdev_driver);</div>
<div class="line"> </div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
<div class="line">MODULE_DESCRIPTION(<span class="stringliteral">&quot;Interrupt handling example&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md298"></a>
Disabling Interrupts</h1>
<h2><a class="anchor" id="autotoc_md299"></a>
Local CPU</h2>
<div class="fragment"><div class="line"><span class="comment">// Disable interrupts on current CPU</span></div>
<div class="line">local_irq_disable();</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">local_irq_enable();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Save and restore interrupt state</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;</div>
<div class="line">local_irq_save(flags);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">local_irq_restore(flags);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md300"></a>
Specific Interrupt</h2>
<div class="fragment"><div class="line"><span class="comment">// Disable specific interrupt</span></div>
<div class="line">disable_irq(irq);</div>
<div class="line"><span class="comment">// Critical section</span></div>
<div class="line">enable_irq(irq);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disable and wait for handler to complete</span></div>
<div class="line">disable_irq_nosync(irq);  <span class="comment">// Don&#39;t wait</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md301"></a>
Interrupt Statistics</h1>
<div class="fragment"><div class="line"># View interrupt statistics</div>
<div class="line">cat /proc/interrupts</div>
<div class="line"> </div>
<div class="line"># View interrupt affinity</div>
<div class="line">cat /proc/irq/42/smp_affinity</div>
<div class="line"> </div>
<div class="line"># Set interrupt affinity (CPU mask)</div>
<div class="line">echo 2 &gt; /proc/irq/42/smp_affinity</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md302"></a>
Best Practices</h1>
<ol type="1">
<li><b>Keep handlers short</b>: Minimize time in interrupt context</li>
<li><b>Use deferred work</b>: For lengthy processing</li>
<li><b>Avoid sleeping</b>: Never sleep in interrupt handlers</li>
<li><b>Check device</b>: For shared interrupts</li>
<li><b>Clear interrupt</b>: Acknowledge hardware interrupt</li>
<li><b>Use spinlocks</b>: For synchronization in interrupt context</li>
<li><b>Return correct value</b>: IRQ_HANDLED or IRQ_NONE</li>
<li><b>Test thoroughly</b>: Interrupt bugs are hard to debug</li>
</ol>
<h1><a class="anchor" id="autotoc_md303"></a>
Common Pitfalls</h1>
<ul>
<li>Sleeping in interrupt context</li>
<li>Using wrong memory allocation flags</li>
<li>Not checking if interrupt is from device</li>
<li>Forgetting to clear hardware interrupt</li>
<li>Deadlocks with spinlocks</li>
<li>Not freeing interrupt on cleanup</li>
</ul>
<h1><a class="anchor" id="autotoc_md304"></a>
Debugging</h1>
<div class="fragment"><div class="line"><span class="comment">// Check if in interrupt context</span></div>
<div class="line"><span class="keywordflow">if</span> (in_interrupt())</div>
<div class="line">    printk(<span class="stringliteral">&quot;In interrupt context\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if in atomic context</span></div>
<div class="line"><span class="keywordflow">if</span> (in_atomic())</div>
<div class="line">    printk(<span class="stringliteral">&quot;In atomic context\n&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md305"></a>
Next Steps</h1>
<p>Proceed to <a class="el" href="md_09-synchronization-waiting-queue.html">Synchronization &amp; Waiting Queue</a> to learn about kernel synchronization mechanisms. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 13 2026 16:02:32 for Linux Driver Development Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
