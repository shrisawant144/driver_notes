<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux Driver Development Manual: Pseudo Char Device Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linux Driver Development Manual
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Comprehensive guide to Linux kernel and device driver development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pseudo Char Device Driver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md221"></a>
Overview</h1>
<p>A pseudo character device driver is a software-only driver that doesn't interact with actual hardware. It's useful for learning driver development concepts and creating virtual devices for testing and inter-process communication.</p>
<h1><a class="anchor" id="autotoc_md222"></a>
Use Cases</h1>
<ul>
<li>Learning and testing driver concepts</li>
<li>Virtual devices for IPC</li>
<li>Device simulation</li>
<li>Data buffering and processing</li>
<li>Debugging and development tools</li>
</ul>
<h1><a class="anchor" id="autotoc_md223"></a>
Simple Pseudo Device</h1>
<h2><a class="anchor" id="autotoc_md224"></a>
Basic Implementation</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/module.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/fs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/cdev.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/device.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/uaccess.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/slab.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define DEVICE_NAME &quot;pseudodev&quot;</span></div>
<div class="line"><span class="preprocessor">#define CLASS_NAME &quot;pseudo&quot;</span></div>
<div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> dev_t dev_num;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>cdev pseudo_cdev;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>class *pseudo_class;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>device *pseudo_device;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> *device_buffer;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">size_t</span> buffer_ptr = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> pseudo_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</div>
<div class="line">{</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Pseudo device opened\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> pseudo_release(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</div>
<div class="line">{</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Pseudo device closed\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t pseudo_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> to_read;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (*f_pos &gt;= buffer_ptr)</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    </div>
<div class="line">    to_read = min(count, buffer_ptr - (<span class="keywordtype">size_t</span>)*f_pos);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, device_buffer + *f_pos, to_read))</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    </div>
<div class="line">    *f_pos += to_read;</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Read %zu bytes\n&quot;</span>, to_read);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_read;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t pseudo_write(<span class="keyword">struct</span> file *filp, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                           <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> to_write;</div>
<div class="line">    </div>
<div class="line">    to_write = min(count, (<span class="keywordtype">size_t</span>)(BUFFER_SIZE - buffer_ptr));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (to_write == 0)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOSPC;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(device_buffer + buffer_ptr, buf, to_write))</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    </div>
<div class="line">    buffer_ptr += to_write;</div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Wrote %zu bytes\n&quot;</span>, to_write);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_write;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>file_operations fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = pseudo_open,</div>
<div class="line">    .release = pseudo_release,</div>
<div class="line">    .read = pseudo_read,</div>
<div class="line">    .write = pseudo_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init pseudo_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Allocate buffer</span></div>
<div class="line">    device_buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!device_buffer)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    memset(device_buffer, 0, BUFFER_SIZE);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Allocate device number</span></div>
<div class="line">    ret = alloc_chrdev_region(&amp;dev_num, 0, 1, DEVICE_NAME);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        kfree(device_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize cdev</span></div>
<div class="line">    cdev_init(&amp;pseudo_cdev, &amp;fops);</div>
<div class="line">    pseudo_cdev.owner = THIS_MODULE;</div>
<div class="line">    </div>
<div class="line">    ret = cdev_add(&amp;pseudo_cdev, dev_num, 1);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        unregister_chrdev_region(dev_num, 1);</div>
<div class="line">        kfree(device_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create class</span></div>
<div class="line">    pseudo_class = class_create(THIS_MODULE, CLASS_NAME);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(pseudo_class)) {</div>
<div class="line">        cdev_del(&amp;pseudo_cdev);</div>
<div class="line">        unregister_chrdev_region(dev_num, 1);</div>
<div class="line">        kfree(device_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(pseudo_class);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create device</span></div>
<div class="line">    pseudo_device = device_create(pseudo_class, NULL, dev_num, NULL, DEVICE_NAME);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(pseudo_device)) {</div>
<div class="line">        class_destroy(pseudo_class);</div>
<div class="line">        cdev_del(&amp;pseudo_cdev);</div>
<div class="line">        unregister_chrdev_region(dev_num, 1);</div>
<div class="line">        kfree(device_buffer);</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(pseudo_device);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Pseudo device initialized\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit pseudo_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    device_destroy(pseudo_class, dev_num);</div>
<div class="line">    class_destroy(pseudo_class);</div>
<div class="line">    cdev_del(&amp;pseudo_cdev);</div>
<div class="line">    unregister_chrdev_region(dev_num, 1);</div>
<div class="line">    kfree(device_buffer);</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Pseudo device removed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(pseudo_init);</div>
<div class="line">module_exit(pseudo_exit);</div>
<div class="line"> </div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
<div class="line">MODULE_AUTHOR(<span class="stringliteral">&quot;Your Name&quot;</span>);</div>
<div class="line">MODULE_DESCRIPTION(<span class="stringliteral">&quot;Simple pseudo character device driver&quot;</span>);</div>
<div class="line">MODULE_VERSION(<span class="stringliteral">&quot;1.0&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md225"></a>
Multiple Device Support</h1>
<h2><a class="anchor" id="autotoc_md226"></a>
Device Structure</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define NUM_DEVICES 4</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>pseudo_device {</div>
<div class="line">    <span class="keyword">struct </span>cdev cdev;</div>
<div class="line">    <span class="keywordtype">char</span> *buffer;</div>
<div class="line">    <span class="keywordtype">size_t</span> size;</div>
<div class="line">    <span class="keywordtype">size_t</span> buffer_ptr;</div>
<div class="line">    <span class="keyword">struct </span>mutex lock;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>pseudo_device *devices;</div>
<div class="line"><span class="keyword">static</span> dev_t dev_num;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>class *pseudo_class;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md227"></a>
Implementation</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> pseudo_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *dev;</div>
<div class="line">    </div>
<div class="line">    dev = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> pseudo_device, cdev);</div>
<div class="line">    filp-&gt;private_data = dev;</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Device opened\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t pseudo_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                          <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">size_t</span> to_read;</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (*f_pos &gt;= dev-&gt;buffer_ptr) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    to_read = min(count, dev-&gt;buffer_ptr - (<span class="keywordtype">size_t</span>)*f_pos);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, dev-&gt;buffer + *f_pos, to_read)) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    *f_pos += to_read;</div>
<div class="line">    mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_read;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t pseudo_write(<span class="keyword">struct</span> file *filp, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                           <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">size_t</span> to_write;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    to_write = min(count, dev-&gt;size - dev-&gt;buffer_ptr);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (to_write == 0) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -ENOSPC;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(dev-&gt;buffer + dev-&gt;buffer_ptr, buf, to_write)) {</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    dev-&gt;buffer_ptr += to_write;</div>
<div class="line">    mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_write;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>file_operations fops = {</div>
<div class="line">    .owner = THIS_MODULE,</div>
<div class="line">    .open = pseudo_open,</div>
<div class="line">    .release = pseudo_release,</div>
<div class="line">    .read = pseudo_read,</div>
<div class="line">    .write = pseudo_write,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init pseudo_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i, ret;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Allocate device structures</span></div>
<div class="line">    devices = kzalloc(NUM_DEVICES * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pseudo_device), GFP_KERNEL);</div>
<div class="line">    <span class="keywordflow">if</span> (!devices)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Allocate device numbers</span></div>
<div class="line">    ret = alloc_chrdev_region(&amp;dev_num, 0, NUM_DEVICES, <span class="stringliteral">&quot;pseudodev&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt; 0) {</div>
<div class="line">        kfree(devices);</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create class</span></div>
<div class="line">    pseudo_class = class_create(THIS_MODULE, <span class="stringliteral">&quot;pseudo&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (IS_ERR(pseudo_class)) {</div>
<div class="line">        unregister_chrdev_region(dev_num, NUM_DEVICES);</div>
<div class="line">        kfree(devices);</div>
<div class="line">        <span class="keywordflow">return</span> PTR_ERR(pseudo_class);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize each device</span></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; NUM_DEVICES; i++) {</div>
<div class="line">        devices[i].size = 1024;</div>
<div class="line">        devices[i].buffer = kmalloc(devices[i].size, GFP_KERNEL);</div>
<div class="line">        <span class="keywordflow">if</span> (!devices[i].buffer) {</div>
<div class="line">            ret = -ENOMEM;</div>
<div class="line">            <span class="keywordflow">goto</span> fail;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        mutex_init(&amp;devices[i].lock);</div>
<div class="line">        </div>
<div class="line">        cdev_init(&amp;devices[i].cdev, &amp;fops);</div>
<div class="line">        devices[i].cdev.owner = THIS_MODULE;</div>
<div class="line">        </div>
<div class="line">        ret = cdev_add(&amp;devices[i].cdev, MKDEV(MAJOR(dev_num), i), 1);</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt; 0)</div>
<div class="line">            <span class="keywordflow">goto</span> fail;</div>
<div class="line">        </div>
<div class="line">        device_create(pseudo_class, NULL, MKDEV(MAJOR(dev_num), i),</div>
<div class="line">                     NULL, <span class="stringliteral">&quot;pseudodev%d&quot;</span>, i);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Created %d pseudo devices\n&quot;</span>, NUM_DEVICES);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">fail:</div>
<div class="line">    <span class="keywordflow">while</span> (i--) {</div>
<div class="line">        device_destroy(pseudo_class, MKDEV(MAJOR(dev_num), i));</div>
<div class="line">        cdev_del(&amp;devices[i].cdev);</div>
<div class="line">        kfree(devices[i].buffer);</div>
<div class="line">    }</div>
<div class="line">    class_destroy(pseudo_class);</div>
<div class="line">    unregister_chrdev_region(dev_num, NUM_DEVICES);</div>
<div class="line">    kfree(devices);</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __exit pseudo_exit(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; NUM_DEVICES; i++) {</div>
<div class="line">        device_destroy(pseudo_class, MKDEV(MAJOR(dev_num), i));</div>
<div class="line">        cdev_del(&amp;devices[i].cdev);</div>
<div class="line">        kfree(devices[i].buffer);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    class_destroy(pseudo_class);</div>
<div class="line">    unregister_chrdev_region(dev_num, NUM_DEVICES);</div>
<div class="line">    kfree(devices);</div>
<div class="line">    </div>
<div class="line">    printk(KERN_INFO <span class="stringliteral">&quot;Pseudo devices removed\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">module_init(pseudo_init);</div>
<div class="line">module_exit(pseudo_exit);</div>
<div class="line"> </div>
<div class="line">MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md228"></a>
FIFO Device (Circular Buffer)</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_SIZE 1024</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>fifo_device {</div>
<div class="line">    <span class="keywordtype">char</span> buffer[BUFFER_SIZE];</div>
<div class="line">    <span class="keywordtype">size_t</span> read_ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> write_ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> count;</div>
<div class="line">    <span class="keyword">struct </span>mutex lock;</div>
<div class="line">    wait_queue_head_t read_queue;</div>
<div class="line">    wait_queue_head_t write_queue;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>fifo_device fifo_dev;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t fifo_read(<span class="keyword">struct</span> file *filp, <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                        <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> to_read, chunk;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;fifo_dev.lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for data</span></div>
<div class="line">    <span class="keywordflow">while</span> (fifo_dev.count == 0) {</div>
<div class="line">        mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)</div>
<div class="line">            <span class="keywordflow">return</span> -EAGAIN;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (wait_event_interruptible(fifo_dev.read_queue, fifo_dev.count &gt; 0))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;fifo_dev.lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    to_read = min(count, fifo_dev.count);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Handle wrap-around</span></div>
<div class="line">    chunk = min(to_read, (<span class="keywordtype">size_t</span>)(BUFFER_SIZE - fifo_dev.read_ptr));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_to_user(buf, fifo_dev.buffer + fifo_dev.read_ptr, chunk)) {</div>
<div class="line">        mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (chunk &lt; to_read) {</div>
<div class="line">        <span class="keywordflow">if</span> (copy_to_user(buf + chunk, fifo_dev.buffer, to_read - chunk)) {</div>
<div class="line">            mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">            <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    fifo_dev.read_ptr = (fifo_dev.read_ptr + to_read) % BUFFER_SIZE;</div>
<div class="line">    fifo_dev.count -= to_read;</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">    </div>
<div class="line">    wake_up_interruptible(&amp;fifo_dev.write_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_read;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t fifo_write(<span class="keyword">struct</span> file *filp, <span class="keyword">const</span> <span class="keywordtype">char</span> __user *buf,</div>
<div class="line">                         <span class="keywordtype">size_t</span> count, loff_t *f_pos)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> to_write, chunk;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;fifo_dev.lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for space</span></div>
<div class="line">    <span class="keywordflow">while</span> (fifo_dev.count == BUFFER_SIZE) {</div>
<div class="line">        mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK)</div>
<div class="line">            <span class="keywordflow">return</span> -EAGAIN;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (wait_event_interruptible(fifo_dev.write_queue,</div>
<div class="line">                                     fifo_dev.count &lt; BUFFER_SIZE))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;fifo_dev.lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    to_write = min(count, (<span class="keywordtype">size_t</span>)(BUFFER_SIZE - fifo_dev.count));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Handle wrap-around</span></div>
<div class="line">    chunk = min(to_write, (<span class="keywordtype">size_t</span>)(BUFFER_SIZE - fifo_dev.write_ptr));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (copy_from_user(fifo_dev.buffer + fifo_dev.write_ptr, buf, chunk)) {</div>
<div class="line">        mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">        <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (chunk &lt; to_write) {</div>
<div class="line">        <span class="keywordflow">if</span> (copy_from_user(fifo_dev.buffer, buf + chunk, to_write - chunk)) {</div>
<div class="line">            mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">            <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    fifo_dev.write_ptr = (fifo_dev.write_ptr + to_write) % BUFFER_SIZE;</div>
<div class="line">    fifo_dev.count += to_write;</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;fifo_dev.lock);</div>
<div class="line">    </div>
<div class="line">    wake_up_interruptible(&amp;fifo_dev.read_queue);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> to_write;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> __init fifo_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    mutex_init(&amp;fifo_dev.lock);</div>
<div class="line">    init_waitqueue_head(&amp;fifo_dev.read_queue);</div>
<div class="line">    init_waitqueue_head(&amp;fifo_dev.write_queue);</div>
<div class="line">    </div>
<div class="line">    fifo_dev.read_ptr = 0;</div>
<div class="line">    fifo_dev.write_ptr = 0;</div>
<div class="line">    fifo_dev.count = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ... rest of initialization</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md229"></a>
IOCTL Support</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;linux/ioctl.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOC_MAGIC &#39;P&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCRESET    _IO(PSEUDO_IOC_MAGIC, 0)</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCGSIZE    _IOR(PSEUDO_IOC_MAGIC, 1, int)</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCSSIZE    _IOW(PSEUDO_IOC_MAGIC, 2, int)</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCGCOUNT   _IOR(PSEUDO_IOC_MAGIC, 3, int)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">long</span> pseudo_ioctl(<span class="keyword">struct</span> file *filp, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *dev = filp-&gt;private_data;</div>
<div class="line">    <span class="keywordtype">int</span> ret = 0;</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (_IOC_TYPE(cmd) != PSEUDO_IOC_MAGIC)</div>
<div class="line">        <span class="keywordflow">return</span> -ENOTTY;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">switch</span> (cmd) {</div>
<div class="line">    <span class="keywordflow">case</span> PSEUDO_IOCRESET:</div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        dev-&gt;buffer_ptr = 0;</div>
<div class="line">        memset(dev-&gt;buffer, 0, dev-&gt;size);</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        printk(KERN_INFO <span class="stringliteral">&quot;Buffer reset\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">case</span> PSEUDO_IOCGSIZE:</div>
<div class="line">        value = dev-&gt;size;</div>
<div class="line">        <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">int</span> __user *)arg, &amp;value, <span class="keyword">sizeof</span>(value)))</div>
<div class="line">            <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">case</span> PSEUDO_IOCSSIZE:</div>
<div class="line">        <span class="keywordflow">if</span> (copy_from_user(&amp;value, (<span class="keywordtype">int</span> __user *)arg, <span class="keyword">sizeof</span>(value)))</div>
<div class="line">            <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (value &lt; 0 || value &gt; 1024 * 1024)</div>
<div class="line">            <span class="keywordflow">return</span> -EINVAL;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Reallocate buffer</span></div>
<div class="line">        <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;dev-&gt;lock))</div>
<div class="line">            <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">        </div>
<div class="line">        kfree(dev-&gt;buffer);</div>
<div class="line">        dev-&gt;buffer = kmalloc(value, GFP_KERNEL);</div>
<div class="line">        <span class="keywordflow">if</span> (!dev-&gt;buffer) {</div>
<div class="line">            mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">            <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        dev-&gt;size = value;</div>
<div class="line">        dev-&gt;buffer_ptr = 0;</div>
<div class="line">        mutex_unlock(&amp;dev-&gt;lock);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">case</span> PSEUDO_IOCGCOUNT:</div>
<div class="line">        value = dev-&gt;buffer_ptr;</div>
<div class="line">        <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">int</span> __user *)arg, &amp;value, <span class="keyword">sizeof</span>(value)))</div>
<div class="line">            <span class="keywordflow">return</span> -EFAULT;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> -ENOTTY;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md230"></a>
Sysfs Attributes</h1>
<div class="fragment"><div class="line"><span class="keyword">static</span> ssize_t buffer_size_show(<span class="keyword">struct</span> device *dev,</div>
<div class="line">                               <span class="keyword">struct</span> device_attribute *attr, <span class="keywordtype">char</span> *buf)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *pdev = dev_get_drvdata(dev);</div>
<div class="line">    <span class="keywordflow">return</span> sprintf(buf, <span class="stringliteral">&quot;%zu\n&quot;</span>, pdev-&gt;size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t buffer_count_show(<span class="keyword">struct</span> device *dev,</div>
<div class="line">                                 <span class="keyword">struct</span> device_attribute *attr, <span class="keywordtype">char</span> *buf)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *pdev = dev_get_drvdata(dev);</div>
<div class="line">    <span class="keywordflow">return</span> sprintf(buf, <span class="stringliteral">&quot;%zu\n&quot;</span>, pdev-&gt;buffer_ptr);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> ssize_t buffer_reset_store(<span class="keyword">struct</span> device *dev,</div>
<div class="line">                                  <span class="keyword">struct</span> device_attribute *attr,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> count)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>pseudo_device *pdev = dev_get_drvdata(dev);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (mutex_lock_interruptible(&amp;pdev-&gt;lock))</div>
<div class="line">        <span class="keywordflow">return</span> -ERESTARTSYS;</div>
<div class="line">    </div>
<div class="line">    pdev-&gt;buffer_ptr = 0;</div>
<div class="line">    memset(pdev-&gt;buffer, 0, pdev-&gt;size);</div>
<div class="line">    </div>
<div class="line">    mutex_unlock(&amp;pdev-&gt;lock);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> DEVICE_ATTR_RO(buffer_size);</div>
<div class="line"><span class="keyword">static</span> DEVICE_ATTR_RO(buffer_count);</div>
<div class="line"><span class="keyword">static</span> DEVICE_ATTR_WO(buffer_reset);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>attribute *pseudo_attrs[] = {</div>
<div class="line">    &amp;dev_attr_buffer_size.attr,</div>
<div class="line">    &amp;dev_attr_buffer_count.attr,</div>
<div class="line">    &amp;dev_attr_buffer_reset.attr,</div>
<div class="line">    NULL,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>attribute_group pseudo_attr_group = {</div>
<div class="line">    .attrs = pseudo_attrs,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In device creation</span></div>
<div class="line">device_create(pseudo_class, NULL, dev_num, &amp;devices[i], <span class="stringliteral">&quot;pseudodev%d&quot;</span>, i);</div>
<div class="line">dev_set_drvdata(pseudo_device, &amp;devices[i]);</div>
<div class="line">sysfs_create_group(&amp;pseudo_device-&gt;kobj, &amp;pseudo_attr_group);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md231"></a>
Testing</h1>
<h2><a class="anchor" id="autotoc_md232"></a>
Test Script</h2>
<div class="fragment"><div class="line">#!/bin/bash</div>
<div class="line"> </div>
<div class="line">DEVICE=&quot;/dev/pseudodev0&quot;</div>
<div class="line"> </div>
<div class="line"># Write to device</div>
<div class="line">echo &quot;Hello, Pseudo Device!&quot; &gt; $DEVICE</div>
<div class="line"> </div>
<div class="line"># Read from device</div>
<div class="line">cat $DEVICE</div>
<div class="line"> </div>
<div class="line"># Check sysfs</div>
<div class="line">cat /sys/class/pseudo/pseudodev0/buffer_size</div>
<div class="line">cat /sys/class/pseudo/pseudodev0/buffer_count</div>
<div class="line"> </div>
<div class="line"># Reset buffer</div>
<div class="line">echo 1 &gt; /sys/class/pseudo/pseudodev0/buffer_reset</div>
<div class="line"> </div>
<div class="line"># Verify reset</div>
<div class="line">cat /sys/class/pseudo/pseudodev0/buffer_count</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md233"></a>
C Test Program</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOC_MAGIC &#39;P&#39;</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCRESET    _IO(PSEUDO_IOC_MAGIC, 0)</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCGSIZE    _IOR(PSEUDO_IOC_MAGIC, 1, int)</span></div>
<div class="line"><span class="preprocessor">#define PSEUDO_IOCGCOUNT   _IOR(PSEUDO_IOC_MAGIC, 3, int)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> fd;</div>
<div class="line">    <span class="keywordtype">char</span> write_buf[] = <span class="stringliteral">&quot;Test data for pseudo device&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> read_buf[256];</div>
<div class="line">    <span class="keywordtype">int</span> size, count;</div>
<div class="line">    </div>
<div class="line">    fd = open(<span class="stringliteral">&quot;/dev/pseudodev0&quot;</span>, O_RDWR);</div>
<div class="line">    <span class="keywordflow">if</span> (fd &lt; 0) {</div>
<div class="line">        perror(<span class="stringliteral">&quot;open&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get buffer size</span></div>
<div class="line">    ioctl(fd, PSEUDO_IOCGSIZE, &amp;size);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Buffer size: %d\n&quot;</span>, size);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Write data</span></div>
<div class="line">    write(fd, write_buf, strlen(write_buf));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get data count</span></div>
<div class="line">    ioctl(fd, PSEUDO_IOCGCOUNT, &amp;count);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Data count: %d\n&quot;</span>, count);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Read data</span></div>
<div class="line">    lseek(fd, 0, SEEK_SET);</div>
<div class="line">    <span class="keywordtype">int</span> n = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf));</div>
<div class="line">    read_buf[n] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Read: %s\n&quot;</span>, read_buf);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Reset buffer</span></div>
<div class="line">    ioctl(fd, PSEUDO_IOCRESET);</div>
<div class="line">    </div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md234"></a>
Best Practices</h1>
<ol type="1">
<li><b>Use proper locking</b> for concurrent access</li>
<li><b>Implement blocking I/O</b> with wait queues</li>
<li><b>Support non-blocking mode</b> (O_NONBLOCK)</li>
<li><b>Provide sysfs interface</b> for configuration</li>
<li><b>Handle errors gracefully</b></li>
<li><b>Clean up resources</b> properly</li>
<li><b>Test with multiple processes</b></li>
</ol>
<h1><a class="anchor" id="autotoc_md235"></a>
Next Steps</h1>
<p>Proceed to <a class="el" href="md_06-platform-device-drivers.html">Platform Device Drivers</a> to learn about platform-specific device drivers. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 13 2026 16:02:32 for Linux Driver Development Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
